[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "John Robin Inston",
    "section": "",
    "text": "Thanks for visiting!\n\nI am a 3rd year Ph.D. student in the Statistics and Applied Probability Department at the University of California Santa Barbara.\nMy broad research interests include quantitative finance, mean field games, control theory and environmental statistics. Currently I am investigating the implementation of Hidden Markov Models for precipitation modelling in California under the supervision of Professor Mike Ludkowski.\nIf you would like to reach out to discuss any of my written work or my research topics please send me a note using the contact page."
  },
  {
    "objectID": "portfolio.html",
    "href": "portfolio.html",
    "title": "Portfolio",
    "section": "",
    "text": "Post With Code\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nJan 20, 2025\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nJan 17, 2025\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index_old.html",
    "href": "index_old.html",
    "title": "johnrobininston.github.io",
    "section": "",
    "text": "Post With Code\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nJan 20, 2025\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nJan 17, 2025\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "Hello and thank you for visiting my blog! In this blog I will post about my ongoing projects, new releases and anything else that I find interesting.\n.\nGoing into my third year as a graduate student at UC Santa Barbara I wanted to make more of an effort to write and publish content that I felt might be helpful to anybody either looking to build their skills in mathematics, statistics and data science, or looking for advice on how to tackle both obtaining and commencing graduate education. This might be a good point to stress that, although I will take the utmost care and attention to ensure that anything I produce is accurate, I will almost surely make mistakes. If you spot any, please feel free to drop me a note here."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "John Robin Inston",
    "section": "",
    "text": "I am a PhD student in the department of statistics and applied probability at UC Santa Barbara. My research interests lie in the intersection of financial mathematics, probability theory and environmental statistics.\n\n\n Back to top"
  },
  {
    "objectID": "about.html#about-me",
    "href": "about.html#about-me",
    "title": "John Robin Inston",
    "section": "About me",
    "text": "About me\nI am passionate about learning and teaching topics in mathematics and statistics and I firmly believe in sharing and collaboration in academia. On my website I am committed to writing posts, sharing my project work and publishing all of the course material I produce for my teaching work.\n\n\n\nRandom walk simulation.\n\n\nIn addition to the posts on my website I will also be posting the same content to my profile on Medium, as well as (hopefully) publishing content on YouTube aiming to provide advice and helpful content for students in STEM."
  },
  {
    "objectID": "resume.html",
    "href": "resume.html",
    "title": "Resume",
    "section": "",
    "text": "Third year PhD student in the Department of Statistics and Applied Probability at the University of California Santa Barbara. Graduate of Lancaster University with a MSc in Quantitative Finance and a BSc in Mathematics with Statistics."
  },
  {
    "objectID": "resume.html#professional-profile",
    "href": "resume.html#professional-profile",
    "title": "Resume",
    "section": "",
    "text": "Third year PhD student in the Department of Statistics and Applied Probability at the University of California Santa Barbara. Graduate of Lancaster University with a MSc in Quantitative Finance and a BSc in Mathematics with Statistics."
  },
  {
    "objectID": "resume.html#research-interests",
    "href": "resume.html#research-interests",
    "title": "Resume",
    "section": "Research Interests",
    "text": "Research Interests\nMy research interests are orientated broadly towards financial mathematics, environmental science and computational statistics with a specific focus on the stochastic management of energy markets and natural resources. Currently, I am conducting research into the multi-period stochastic mangement of California ground water resources under the supervision of Dr Michael Ludkovski."
  },
  {
    "objectID": "resume.html#education",
    "href": "resume.html#education",
    "title": "Resume",
    "section": "Education",
    "text": "Education\n\n\n2022 - Present\nUC Santa Barbara\n\nPhD Statistics and Applied Probability\nTopics Studied: (1) Probability Theory, (2) Statistical Theory, (3) Machine Learning, (4) Energy Finance, (5) Financial Models, (6) Advanced Time Series Methods, (7) Advanced Statistical Methods, (8) Bayesian Analysis, (9) High-Frequency Trading (10) Blockastics.\n\n\n\n\n2020 - 2021 Lancaster University\n\nMSc Quantitative Finance (Distinction)\nSupervisors: Dr George Wang (Lancaster University), Professor Ian D’Souza (NYU Stern)\nDissertation Title: Measuring and Forecasting Mutual Fund Survival Capacity using Machine Learning Algorithms.\nTopics Studied: (1) Foundations in Financial Markets, (2) Derivatives Pricing, (3) Financial Econometrics, (4) Market Risk Forecasting and Control, (5) Stochastic Calculus for Finance, (6) Financial Stochastic Processes, (7) Statistical Methods for Financial and Economic Applications, (8) Assessing Financial Risk: Extreme Value Methods, (9) Spreadsheet Modelling for Quantitative Finance and (10) Forecasting.\n\n\n\n\n2013 - 2018 Lancaster University\n\nBSc Mathematics with Statistics (First Class Honors)\nTopics Studied: (1) Metric Spaces, (2) Differential Equations, (3) Combinatorics, (4) Likelihood Inference, (5) Bayesian Inference, (6) Statistical Modelling, (7) Time Series Analysis, (8) Real Analysis, (9) Complex Analysis, (10) Linear Algebra, (11) Groups and Rings, (12) Probability and (13) Statistics."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Fundamentals of Probability Theory\n\n\n\nData Science with R\n\nProbability Theory\n\n\n\n\n\n\n\n\n\nJun 1, 2025\n\n\nJohn Robin Inston\n\n\n\n\n\n\n\n\n\n\n\n\nR Basics III - Dataframes and Lists\n\n\n\nData Science with R\n\n\n\n\n\n\n\n\n\nMar 24, 2025\n\n\nJohn Robin Inston\n\n\n\n\n\n\n\n\n\n\n\n\nR Basics II - Atomic Data Structures\n\n\n\nData Science with R\n\n\n\n\n\n\n\n\n\nMar 23, 2025\n\n\nJohn Robin Inston\n\n\n\n\n\n\n\n\n\n\n\n\nR Basics I - Operators, Logic & Data Types\n\n\n\nData Science with R\n\n\n\n\n\n\n\n\n\nMar 8, 2025\n\n\nJohn Robin Inston\n\n\n\n\n\n\n\n\n\n\n\n\nInstalling and using R and RStudio\n\n\n\nData Science with R\n\n\n\n\n\n\n\n\n\nMar 8, 2025\n\n\nJohn Robin Inston\n\n\n\n\n\n\n\n\n\n\n\n\nUpdate: Qualified at last!\n\n\n\nNews\n\n\n\n\n\n\n\n\n\nMar 8, 2025\n\n\nJohn Robin Inston\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\nNews\n\n\n\n\n\n\n\n\n\nJan 21, 2025\n\n\nJohn Robin Inston\n\n\n\n\n\nNo matching items\n Back to top"
  },
  {
    "objectID": "posts/welcome/index.html#new-beginnings",
    "href": "posts/welcome/index.html#new-beginnings",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "Hello and thank you for visiting my blog! In this blog I will post about my ongoing projects, new releases and anything else that I find interesting.\n.\nGoing into my third year as a graduate student at UC Santa Barbara I wanted to make more of an effort to write and publish content that I felt might be helpful to anybody either looking to build their skills in mathematics, statistics and data science, or looking for advice on how to tackle both obtaining and commencing graduate education. This might be a good point to stress that, although I will take the utmost care and attention to ensure that anything I produce is accurate, I will almost surely make mistakes. If you spot any, please feel free to drop me a note here."
  },
  {
    "objectID": "posts/welcome/index.html#plans-going-forward",
    "href": "posts/welcome/index.html#plans-going-forward",
    "title": "Welcome To My Blog",
    "section": "Plans going forward",
    "text": "Plans going forward\nMy plans are to consistently produce useful and engaging content in the form of YouTube videos, website posts and projects, and study material. Some of the topics I am interested in writing about include:\n\nHelpful software for students:\n\nNotion for life planning and organization\nObsidian for study, document referencing and creation\nZotero for reference management\nTechnical writing using LaTeX and Markdown in Quarto\n\nTopics in mathematics and statistics:\n\nProbability Theory\nStochastic Processes\nLinear Algebra\nFinancial Mathematics\nStatistical Modelling\n\nTopics in data science:\n\nProgramming in R, Python, and SQL\nCoding projects\n\nCareer planning and guidance:\n\nHow to make career decisions\nHow to prepare for technical interviews\n\nAdvice for graduate students:\n\nHow to prepare class material using Quarto and GitHub\nHow to create a personal website / blog\n\n\nAdditionally I also plan to write about my ongoing research projects. I am currently involved in two topics, one investigating modelling groundwater in California and the other investigating the survival capacity of actively managed mutual funds in the United States."
  },
  {
    "objectID": "posts/welcome/index.html#teething-problems",
    "href": "posts/welcome/index.html#teething-problems",
    "title": "Welcome To My Blog",
    "section": "Teething Problems",
    "text": "Teething Problems\nThis is my first time taking on such an ambitious plan of producing and publishing content. Although I apologize in advance for any broken links, poor formatting and missed posting deadlines, I hope that something I write might prove helpful!"
  },
  {
    "objectID": "posts/welcome_post/index.html",
    "href": "posts/welcome_post/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "Hello and thank you for visiting my blog! In this blog I will post about my ongoing projects, new releases and anything else that I find interesting.\n\n\n\nImage taken by OC Gonzalez, find him on instagram at @OCVISUAL.\n\n\nGoing into my third year as a graduate student at UC Santa Barbara I wanted to make more of an effort to write and publish content that I felt might be helpful to anybody either looking to build their skills in mathematics, statistics and data science, or looking for advice on how to tackle both obtaining and commencing graduate education. This might be a good point to stress that, although I will take the utmost care and attention to ensure that anything I produce is accurate, I will almost surely make mistakes. If you spot any, please feel free to drop me a note here."
  },
  {
    "objectID": "posts/welcome_post/index.html#new-beginnings",
    "href": "posts/welcome_post/index.html#new-beginnings",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "Hello and thank you for visiting my blog! In this blog I will post about my ongoing projects, new releases and anything else that I find interesting.\n\n\n\nImage taken by OC Gonzalez, find him on instagram at @OCVISUAL.\n\n\nGoing into my third year as a graduate student at UC Santa Barbara I wanted to make more of an effort to write and publish content that I felt might be helpful to anybody either looking to build their skills in mathematics, statistics and data science, or looking for advice on how to tackle both obtaining and commencing graduate education. This might be a good point to stress that, although I will take the utmost care and attention to ensure that anything I produce is accurate, I will almost surely make mistakes. If you spot any, please feel free to drop me a note here."
  },
  {
    "objectID": "posts/welcome_post/index.html#plans-going-forward",
    "href": "posts/welcome_post/index.html#plans-going-forward",
    "title": "Welcome To My Blog",
    "section": "Plans going forward",
    "text": "Plans going forward\nMy plans are to consistently produce useful and engaging content in the form of YouTube videos, website posts and projects, and study material. Some of the topics I am interested in writing about include:\n\nHelpful software for students:\n\nNotion for life planning and organization\nObsidian for study, document referencing and creation\nZotero for reference management\nTechnical writing using LaTeX and Markdown in Quarto\n\nTopics in mathematics and statistics:\n\nProbability Theory\nStochastic Processes\nLinear Algebra\nFinancial Mathematics\nStatistical Modelling\n\nTopics in data science:\n\nProgramming in R, Python, and SQL\nCoding projects\n\nCareer planning and guidance:\n\nHow to make career decisions\nHow to prepare for technical interviews\n\nAdvice for graduate students:\n\nHow to prepare class material using Quarto and GitHub\nHow to create a personal website / blog\n\n\nAdditionally I also plan to write about my ongoing research projects. I am currently involved in two topics, one investigating modelling groundwater in California and the other investigating the survival capacity of actively managed mutual funds in the United States."
  },
  {
    "objectID": "posts/welcome_post/index.html#teething-problems",
    "href": "posts/welcome_post/index.html#teething-problems",
    "title": "Welcome To My Blog",
    "section": "Teething Problems",
    "text": "Teething Problems\nThis is my first time taking on such an ambitious plan of producing and publishing content. Although I apologize in advance for any broken links, poor formatting and missed posting deadlines, I hope that something I write might prove helpful!"
  },
  {
    "objectID": "courses.html",
    "href": "courses.html",
    "title": "Courses",
    "section": "",
    "text": "Linear Algebra\n\n\n\nMathematics\n\nLinear Algebra\n\n\n\n\n\n\n\nJohn Robin Inston\n\n\nMay 30, 2025\n\n\n\n\n\n\n\n\n\n\n\nProbability Theory\n\n\n\nMathematics\n\nProbability\n\n\n\n\n\n\n\nJohn Robin Inston\n\n\nJan 21, 2025\n\n\n\n\n\n\n\n\n\n\n\nData Science with R\n\n\n\nData Science\n\nR\n\n\n\n\n\n\n\nJohn Robin Inston\n\n\nJan 21, 2025\n\n\n\n\n\n\nNo matching items\n Back to top"
  },
  {
    "objectID": "courses/intro_to_data_science/index.html",
    "href": "courses/intro_to_data_science/index.html",
    "title": "Data Science with R",
    "section": "",
    "text": "── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'"
  },
  {
    "objectID": "courses/intro_to_data_science/index.html#data-science-with-r",
    "href": "courses/intro_to_data_science/index.html#data-science-with-r",
    "title": "Data Science with R",
    "section": "",
    "text": "Welcome to my course titled Data Science with R which provides an introduction on how to use the programming language R for data science and statistical modelling.\nThe aim of this course is to provide a thorough introduction to programming in R for individuals who may have never written or utilized a programming language before. First we outline how to install R on our operating system, how to download and use an Interactive Development Environment (IDE) such as RStudio, Positron or VSCode, and how to install packages on our system. We will then explore various ways to explore, manage and analyze data using both the in-built functionality in R as well as available libraries such as tidyverse.\n\n\n\nIf you are taking this course as a student in PSTAT10 at UCSB then you can find my grading breakdown in the most recent syllabus"
  },
  {
    "objectID": "resume.html#working-papers",
    "href": "resume.html#working-papers",
    "title": "Resume",
    "section": "Working Papers",
    "text": "Working Papers\n\nMeasuring and Forecasting Mutual Fund Survivial Capacity using Machine Learning Algorithms, with Dr George Wang (Lancaster University Management School) and Ian D’Souza (NYU Stern)."
  },
  {
    "objectID": "resume.html#teaching-experience",
    "href": "resume.html#teaching-experience",
    "title": "Resume",
    "section": "Teaching Experience",
    "text": "Teaching Experience\nYou can download a pdf copy of my resume here."
  },
  {
    "objectID": "resume.html#courses-taugh",
    "href": "resume.html#courses-taugh",
    "title": "Resume",
    "section": "Courses Taugh",
    "text": "Courses Taugh\n\nTeaching Associate\n\nPSTAT10 Introduction to Data Science\n\n2023 - 2024 • PSTAT175 Survival Analysis • PSTAT8 Introduction to Mathematical Proof • PSTAT274 Time Series Analysis • PSTAT10 Data Science Principles • PSTAT5LS Life Science Statistics 3 2022 - 2023 • PSTAT120C Probability and Statistics • PSTAT5A Understanding Data\nYou can download a pdf copy of my resume here."
  },
  {
    "objectID": "resume.html#courses",
    "href": "resume.html#courses",
    "title": "Resume",
    "section": "Courses",
    "text": "Courses\n\nTeaching Associate\n\nPSTAT10 Introduction to Data Science\n\n\n\nTeaching Assistant\n\nPSTAT175 Survival Analysis\nPSTAT8 Introduction to Mathematical Proof\nPSTAT274 Time Series Analysis\nPSTAT5LS Life Science Statistics\nPSTAT120C Probability and Statistics\nPSTAT5A Understanding Data\n\nYou can download a pdf copy of my resume here."
  },
  {
    "objectID": "resume.html#employment",
    "href": "resume.html#employment",
    "title": "Resume",
    "section": "Employment",
    "text": "Employment\n\n\n2025 - Present\nUC Santa Barbara\n\nGraduate Student Researcher\n\n\n\n\n2022 - 2024\nUC Santa Barbara\n\nTeaching Assistant / Teaching Associate\n\n\n\n\n2021 - 2022 Lancaster University\n\nResearch Assistant"
  },
  {
    "objectID": "resume.html#teaching",
    "href": "resume.html#teaching",
    "title": "Resume",
    "section": "Teaching",
    "text": "Teaching\n\nPSTAT10 Introduction to Data Science\nPSTAT175 Survival Analysis\nPSTAT8 Introduction to Mathematical Proof\nPSTAT274 Time Series Analysis\nPSTAT5LS Life Science Statistics\nPSTAT120C Probability and Statistics\nPSTAT5A Understanding Data"
  },
  {
    "objectID": "resume.html#awards",
    "href": "resume.html#awards",
    "title": "Resume",
    "section": "Awards",
    "text": "Awards\n\nAward for Best Academic Performance 2020/21\nAwarded in recognition of exceptional academic performance in obtaining the highest GPA on the MSc Quantitative Finance programme at Lancaster University in the 2020/21 academic year.\nAward for Best Dissertation Results 2020/21\nAwarded in recognition of obtaining the highest dissertation results on the MSc Quantitative Finance programme at Lancaster University in the 2020/21 academic year.\nLancaster Gold Award\nAwarded in recognition of skills obtained in activities outside of academia whilst at university. These include: (1) Digital Skills Certificate, (2) Charity Work, (3) Work Experience, and (4) Student Academic Representative.\n\nFor details of my project work please see my projects page. To download a pdf copy of my full academic resume please click here."
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "Implementing Black Scholes and Vasiciek Models in R\n\n\n\nQuantitative Finance\n\n\nOption Pricing\n\n\nR\n\n\n\n\n\n\n\nJohn Robin Inston\n\n\nMar 9, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nForecasting historical atmospheric carbon dioxide levels above Mauna Loa, Hawaii using the SARIMA model family.\n\n\n\nAtmospheric Modelling\n\n\nTime Series\n\n\nStatistics\n\n\nR\n\n\nSARIMA\n\n\n\n\n\n\n\nJohn Robin Inston\n\n\nJun 17, 2023\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "projects/atmospheric_co2_time_series/index.html",
    "href": "projects/atmospheric_co2_time_series/index.html",
    "title": "Forecasting historical atmospheric carbon dioxide levels above Mauna Loa, Hawaii using the SARIMA model family.",
    "section": "",
    "text": "Abstract:\nIn this report we aim to select and fit an appropriate Seasonal Autoregressive Integrated Moving Average (SARIMA) model in order to produce accuruate five year ahead forecasts of atmospheric CO2 levels above Mauna Loa, Hawaii. We investigate the underlying properties of the time series data, the suitability of SARIMA models, and whether the forecasts they produce accurately capture future observations. Throughout the project we implement various univariate time series analysis techniques including exploratory analysis, model selection procedures based on the adjusted Akaike Information Criteria, diagnostic checking, residual analysis and spectral analysis. Our first choice \\(\\text{SARIMA}(0,1,3)(0,1,1)_{12}\\) model performed well, producing approximately Gaussian WN residuals and accurate forecasts with confidence intervals capturing the true observed future values of the time series."
  },
  {
    "objectID": "projects/atmospheric_co2_time_series/index.html#introduction",
    "href": "projects/atmospheric_co2_time_series/index.html#introduction",
    "title": "Forecasting historical atmospheric carbon dioxide levels above Mauna Loa, Hawaii using the SARIMA model family.",
    "section": "Introduction",
    "text": "Introduction\nSeveral geophysical time series contain seasonal variation with one key example being carbon dioxide (CO\\(_2\\)) atmospheric concentration which typically is known to have annual seasonality - largely due to plant photosynthesis and respiration - superimposed upon an increasing trend caused primarily by human CO\\(_2\\) production. In this project we examine a data set consisting of monthly measurements of atmospheric CO\\(_2\\) above Mauna Lao, Hawaii in the 32 year period from between 1959 and 1990 with the aim of producing accurate forecasts - in our case a 5 year ahead forecast - by fitting a suitable model from the SARIMA model family. We use a variety of time series analysis including exploratory analysis (time series decomposition, stationarity transformations, inspecting series autocorrelations and partial autocorrelations, tests for normality, stationarity and autocorrelation), SARIMA fitting and model selection (checking for stationarity and invertibility, coefficient significance testing, performance criteria) and residual analysis (portmanteau tests, residual WN tests, model spectral decomposition). We find that the \\(\\text{SARIMA}(0,1,3)(0,1,1)_{12}\\) model is our optimal model candidate and our subsequent residual analysis, forecasting and spectral decomposition indicates that our model produces accurate forecasts which captured the future true observations of the time series. Our analysis was performed using the programming language R and a full breakdown of our code can be found in the corresponding GitHub repository."
  },
  {
    "objectID": "projects/vasiciek_model/index.html",
    "href": "projects/vasiciek_model/index.html",
    "title": "Implementing Black Scholes and Vasiciek Models in R",
    "section": "",
    "text": "This is a report I completed in 2020 during my time studying towards my masters degree in Quantitative Finance at Lancaster University.\nAbstract:\nIn this mini project we investigate the properties of financial stochastic processes. We first consider the implementation of the Black-Scholes model for determining the price of European call options on stock before then utilising the Vasicek model to calculate the future price of bonds. We discuss the background, benefits and drawbacks of both models before conducting our investigation and summarising our findings."
  },
  {
    "objectID": "projects/vasiciek_model/index.html#quick-summary",
    "href": "projects/vasiciek_model/index.html#quick-summary",
    "title": "Implementing Black Scholes and Vasiciek Models in R",
    "section": "",
    "text": "In this project we investigate the properties of financial stochastic processes. We first consider the implementation of the Black-Scholes model for determining the price of European call options on stock before then utilising the Vasicek model to calculate the future price of bonds. We discuss the background, benefits and drawbacks of both models before conducting our investigation and summarising our findings."
  },
  {
    "objectID": "projects/vasiciek_model/index.html#introduction",
    "href": "projects/vasiciek_model/index.html#introduction",
    "title": "Implementing Black Scholes and Vasiciek Models in R",
    "section": "Introduction",
    "text": "Introduction\nThe Black-Scholes model is a mathematical model developed by the economists Fischer Black, Myron Scholes and Robert Merton which is widely used in the pricing of options contacts. The model assumes that the price of heavily traded assets follows a geometric Brownian motion with constant drift and volatility. When applied to a stock option, the model incorporates the constant price variation of the stock, the time value of money, the option’s strike price, and the time to the option’s expiry.\nThe Vasicek model is a mathematical model used in financial economics to estimate potential pathways for future interest rate changes. The model states that the movement of interest rates is affected only by random (stochastic) market movements and models interest rate movements as a factor composed of market risk, time, and equilibrium value - where the rate tends to revert towards the mean of those factors over time.\nWe will first investigate how the price of a European call option - as given by the Black- Scholes model - varies with changes in time, interest rates, strike price and volatility. We will then simulate an Ornstein-Uhlenbeck process and use this to simulate the price of a bond - using the Vasicek model - over a given time period before evaluating the distribution of the simulated prices.\nWe conduct this project using the programming language R along with the ggplot2, reshape, tidyr and gridExtra packages.\n\n# Libraries\nlibrary(ggplot2)\nlibrary(reshape)\nlibrary(tidyr)\nlibrary(gridExtra)\n\n# Plot theme\ntheme_set(theme_light())\n\n# Reproducibility\nset.seed(555)"
  },
  {
    "objectID": "projects/atmospheric_co2_time_series/index.html#data",
    "href": "projects/atmospheric_co2_time_series/index.html#data",
    "title": "Forecasting historical atmospheric carbon dioxide levels above Mauna Loa, Hawaii using the SARIMA model family.",
    "section": "Data",
    "text": "Data\n\nData Description\nOur data set contains monthly measurements of atmospheric carbon dioxide above Mauna Loa, Hawaii from January 1959 to December 1990, measured in parts per million (ppm). The data was originally collected from the Scripps Institute of Oceanography, La Jolla, California and made readily available through the tsdlpackage developed by Rob Hyndman, Professor of Statistics at Monash University, Australia. The data set initially contained missing values which were subsequently filled in by linear interpolation. Our raw data series, labelled by \\(x_t\\), \\(t = 1, ..., 384\\) contains 384 observations.\n\n\nExploratory Analysis\nWe split our data into disjoint training and testing sets, with the latter containing the last 5 years of observed CO\\(_2\\) levels to be used to analyse the performance of the foreacsts produced by our chosen final model. Our training data set contains 324 observations whilst our testing data set contains 60. Using the training data we produce a time series plot, shown below in Figure 1.\n\n\n\n\n\n\n\n\nFigure 1: Atmospheric carbon dioxide above Mauna Loa, Hawaii.\n\n\n\n\n\nWe see clear evidence of both an increasing polynomial trend and a seasonal component (with a 12 month period) implying that our raw data is non-stationary. The variance of our data appears constant and there is no evidence of sharp changes in behaviour indicating that a SARIMA model will likely suit our data well. We decompose the time series in Figure 2 below to provide a clearer picture of the seasonal and trend components and since we observe no evidence of heteroscedastic behaviour in the residuals we opt not to transform our data.\n\n\n\n\n\n\n\n\nFigure 2: Time Series Decomposition\n\n\n\n\n\nWe produce a plot of the autocorrelation function (ACF) of the data, shown below in Figure 3, from which we see highly significant autocorrelations for all lags up to 40 which slowly decay and show seasonality.\n\n\n\n\n\n\n\n\nFigure 3: ACF and PACF of raw data.\n\n\n\n\n\nWe attempt to obtain stationarity by differencing, first with lag 12 to remove the seasonal trend. Mathematically this transformation is denoted:\n\\[\\begin{equation}\\tag{1}\ny_t = x_t−x_{t−12} = (1−B^{12})x_t = ∇_{12}x_t,\n\\end{equation}\\]\nwhere \\(y_t\\) is our seasonally differenced data series and B is the back-shift operator whereby \\(B^kx_t = x_{t−k}\\). A time series plot of our differenced data is shown below in Figure 4 along with a trend line, from which we can see that all evidence of a seasonal trend has been removed but the data appears to still be non-stationary as a linear trend is still present. Alongside we include the ACF plot of our seasonally differenced data from which we see the decaying autocorrelation typical of data with a polynomial trend.\n\n\n\n\n\n\n\n\nFigure 4: Time series plot, ACF and PACF of seasonally differenced data.\n\n\n\n\n\nWe therefore difference again with lag 1 to remove the linear trend from in the data, denoted mathematically by:\n\\[\\begin{equation}\\tag{2}\nu_t = y_t−y_{t−1} = (1−B)y_t = (1−B)(1−B^{12})x_t = ∇_1∇_{12}x_t,\n\\end{equation}\\]\nwhere \\(u_t\\) is our twice differenced data. We produce another time series plot of our twice differenced data below in Figure 5.\n\n\n\n\n\n\n\n\n\n\n\n\n\nOur twice differenced data now appears stationary with no evidence of seasonality or polynomial trends with a stable variance in time. In Table 1 below we see that each transformation lowered the variance of our data.\n\n\n\n\nTable 1: Transformed data variance stationarity test result.\n\n\n\n\n\n\nTransformation\nVariance\n\n\n\n\nNone\n86.0367259\n\n\nDifferenced lag 12\n0.3449074\n\n\nDifferenced lag 12 and lag 1\n0.1577327\n\n\n\n\n\n\n\n\nIn Figure 6 we see that the ACF of our twice differenced data shows no evidence of polynomial or seasonal trends. Further both the histogram and Q-Q plot shows that the empirical distribution of our data is symmetric and approximately Gaussian.\n\n\n\n\n\n\n\n\nFigure 6: ACF, PACF, histogram and Q-Q plot of twice differenced data.\n\n\n\n\n\nFinally, in Table 2 we see the p-values for both the Augmented Dickey–Fuller (ADF) t-statistic test (which examines whether the series has a unit root where a series with a trend line will have a unit root and result in a large p-value); and the Kwiatkowski-Phillips-Schmidt-Shin (KPSS) test (which tests the null hypothesis of trend stationarity where a low p-value will indicate a signal that is not trend stationary, has a unit root), both of which concluded that the twice differenced data is trend stationary.\n\n\n\n\nTable 2: ADF and KPSS test result.\n\n\n\n\n\n\n\n\n\n\n\n\nTest\nNull\npValue\nConclusion\n\n\n\n\nADF Test\nProcess has a unit root and therefore a trend.\n&lt;0.01\nData is stationary\n\n\nKPSS Test\nProcess is stationary\n&gt;0.1\nData is stationary"
  },
  {
    "objectID": "projects/atmospheric_co2_time_series/index.html#model-fitting",
    "href": "projects/atmospheric_co2_time_series/index.html#model-fitting",
    "title": "Forecasting historical atmospheric carbon dioxide levels above Mauna Loa, Hawaii using the SARIMA model family.",
    "section": "Model Fitting",
    "text": "Model Fitting\n\nParameter Selection\nWhen considering a potential SARIMA model we are required to select possible values for the 7 parameters \\(p\\), \\(d\\), \\(q\\), \\(P\\), \\(D\\), \\(Q\\) and \\(s\\). Since we differenced our data with lag 1 once and with lag 12 once to obtain stationarity we have the parameters \\(d=1\\), \\(D=1\\) and \\(s = 12\\). To determine a potential range of values of the remaining parameters (AR parameters \\(p\\), \\(P\\) and MA parameters \\(q\\), \\(Q\\)) we examine both the ACF and PACF plots of the differenced data, shown above in Figure 6.\nTo determine an upper bound for the AR term \\(p\\) range we look at the PACF and see that we have significant partial-autocorrelation spikes at lags 1 and 3 indicating we may require up to \\(p= 3\\). We also note there are significant spikes at lags 9 and 11 although these are likely interactions with seasonal components to be considered later. To determine an upper bound for the MA term \\(q\\) range we look at the ACF and see that we have significant autocorrelation spikes at lags 1 and 3, indicating we may require up to \\(q= 3\\). Similarly, we also see significant spikes at lags 9 and 11, likely due to interactions with seasonal components.\nNow considering seasonal AR terms we again turn to the PACF, this time noting that we have significant partial-autocorrelation at lags 12,24 and 36 indicating that we may require a seasonal AR parameter up to \\(P= 3\\). Finally, to determine an upper bound for the seasonal MA term Q range we note from the ACF plot that we have significant autocorrelation at lag 12 only, indicating the we likely require a seasonal MA parameter of \\(Q= 1\\).\nWe proceed to select the two models using a procedure whereby we systematically fit, evaluate and compare models using the Akaike information criterion (adjusted for small sample sizes) - denoted AICc. Earlier we determined that at most our model with have up to \\(p= 3\\), \\(q= 3\\), \\(P= 3\\) and \\(Q= 1\\) however, since the AICc punishes models with large numbers of parameters our approach to selecting an optimal model will be to start with the simplest models and add parameters with the aim of minimizing the AICc.\n\n\n\n\nTable 3: Model comparison summary (Significance codes: 0 \\(\\text{***}\\), 0.001 \\(\\text{**}\\), 0.01 \\(\\text{*}\\), 0.05 .).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModel\nar1\nar2\nar3\nma1\nma2\nma3\nsar1\nsma1\nAICc\n\n\n\n\nSARIMA(0,1,1)(0,1,0)12\n\n\n\n-0.344***\n\n\n\n\n279.55\n\n\nSARIMA(0,1,0)(0,1,1)12\n\n\n\n\n\n\n\n-0.890***\n154.53\n\n\nSARIMA(0,1,2)(0,1,0)12\n\n\n\n-0.346***\n-0.047\n\n\n\n280.87\n\n\nSARIMA(0,1,1)(0,1,1)12\n\n\n\n-0.353***\n\n\n\n-0.841***\n123.84\n\n\nSARIMA(0,1,3)(0,1,0)12\n\n\n\n-0.325***\n0.013\n-0.217***\n\n\n270.05\n\n\nSARIMA(0,1,2)(0,1,1)12\n\n\n\n-0.354***\n-0.046\n\n\n-0.839***\n125.30\n\n\nSARIMA(0,1,3)(0,1,1)12\n\n\n\n-0.356***\n0.004\n-0.157**\n\n-0.838***\n119.57\n\n\nSARIMA(0,1,3)(0,1,0)12 (MA2=0)\n\n\n\n-0.322***\n0\n-0.214***\n\n\n268.05\n\n\nSARIMA(0,1,3)(0,1,1)12 (MA2=0)\n\n\n\n-0.355***\n0\n-0.156**\n\n-0.838***\n117.51\n\n\nSARIMA(1,1,1)(0,1,1)12\n0.345*\n\n\n-0.675***\n\n\n\n-0.839***\n123.37\n\n\nSARIMA(0,1,1)(1,1,1)12\n\n\n\n-0.357***\n\n\n-0.031\n-0.831***\n125.69\n\n\nSARIMA(1,1,3)(0,1,1)12 (MA2=0)\n0.026\n\n\n-0.377**\n0\n-0.152**\n\n-0.839***\n119.55\n\n\nSARIMA(3,1,3)(0,1,1)12 (MA2=0)\n0.660\n0.235\n-0.269\n-1.007*\n0\n0.193\n\n-0.846***\n123.1\n\n\nSARIMA(3,1,1)(0,1,1)12\n0.371*\n0.139.\n-0.103\n-0.722***\n\n\n\n-0.841***\n121.15\n\n\nSARIMA(3,1,1)(0,1,1)12 (AR1=AR2=0)\n0\n0\n-0.139*\n-0.347***\n\n\n\n-1.196***\n119.96\n\n\n\n\n\n\n\n\n\n\nPure Moving Average Models\nWe begin by fixing our AR parameters \\(p= 0\\) and \\(P= 0\\) and determine the optimal pure Moving Average (MA) model. From our ACF and PACF plots we determined that our model should include up to \\(q= 3\\) MA terms and \\(Q= 1\\) seasonal MA terms. We proceed to fit various models with the results of the fitting procedure for our top performing models, shown below in Table 4.\n\n\n\n\nTable 4: MA model performance criteria.\n\n\n\n\n\n\nModel\nAIC\nAICc\nBIC\n\n\n\n\nSARIMA(0,1,3)(0,1,1)12\n119.38\n119.57\n138.08\n\n\nSARIMA(0,1,3)(0,1,1)12 (MA2=0)\n117.38\n117.51\n132.34\n\n\n\n\n\n\n\n\nFrom Table 4 we see that the SARIMA(0,1,3)(0,1,1)12 model obtained an AICc of 119.57 and that of our 4 fitted coefficients, the MA(2) parameter is insignificant - since the confidence interval contains 0. Therefore, we fix this term to 0 and refit our model. Our adjustment was successful with our new model achieving a lower AICc score of 117.51 and significant coefficients making this as our top performing pure MA model.\n\n\nConsidering Autoregressive Terms\nWe consider whether the introduction of autoregressive terms improves model performance per the AICc - namely whether the introduction of additional autoregressive terms improve performance enough that it outweighs the penalty from the AICc. We again consider a selection of models containing AR terms and show the fitting procedure results of our top two candidates in Table 5 below.\n\n\n\n\nTable 5: AR model performance criteria.\n\n\n\n\n\n\nModel\nAIC\nAICc\nBIC\n\n\n\n\nSARIMA(1,1,1)(0,1,1)12\n123.24\n123.37\n138.20\n\n\nSARIMA(3,1,1)(0,1,1)12 (AR1=AR2=0)\n119.83\n119.96\n134.79\n\n\n\n\n\n\n\n\nWe found that the addition of seasonal AR terms typically decreased our models AICc and rarely had significant coefficients. From Table 5 we see that the SARIMA(1,1,1)(0,1,1)12 model performed reasonably well, with all fitted coefficients being significant and achieving an AICc of 123.37. Furthermore, from Table 5 we also see that a potential candidate is the SARIMA(3,1,1)(0,1,1)12 model with fixed zero AR(1) and AR(2) coefficients. This model again has all significant coefficients with an AICc of 119.96, making it the second best performing model overall per the AICc, however this model is not a viable candidate as the absolute value of the seasonal MA coefficient is greater than 1. Hence select the SARIMA(1,1,1)(0,1,1)12 model as our second candidate and proceed to confirming stationarity and invertibility.\n\n\nFinal Model\nThe equations for our selected models are therefore:\n\n\\(\\nabla_{1}\\nabla_{12}X_t = (1-0.354998_{(0.053140)}B-0.155974_{(0.052126)}B^3)(1-0.838438_{(0.035989)}B^{12})Z_t,\\)\n\\(\\nabla_1\\nabla_{12}(1-0.344624_{(0.151353)}B)X_t=(1-0.675336_{(0.123186)}B)(1-0.839105_{(0.035565)}B^{12})Z_t\\)\n\nwhere \\(Z_t\\) is White Noise (WN) with \\(\\mathbb{E}Z_t=0\\) with \\(\\text{Var}(Z_t)=\\hat{\\sigma}_Z^2 =0.08431\\) and \\(\\hat{\\sigma}_Z^2=0.08583\\) respectively.\nModel (1) is pure moving average so it is always stationary. Furthermore, from plot 1 in Figure 8 below we see that all MA roots lie outside the unit circle and since \\(|\\Theta_1|&lt; 1\\) we have that the model is invertible. Model (B) is invertible since \\(|\\theta_1|&lt; 1\\) and \\(|\\Theta_1|&lt; 1\\) and the model is stationary since \\(|\\phi_1|&lt; 1\\)."
  },
  {
    "objectID": "about.html#welcome",
    "href": "about.html#welcome",
    "title": "About Me",
    "section": "Welcome!",
    "text": "Welcome!\n\nThank you for visiting my website."
  },
  {
    "objectID": "about.html#education-timeline",
    "href": "about.html#education-timeline",
    "title": "John Robin Inston",
    "section": "Education Timeline",
    "text": "Education Timeline\n\n\n\nIn 2013 I commenced my undergraduate study at Lancaster University studying Theoretical Physics.\nBetween 2014 and 2016 I changed course twice, first to Mechanical Engineering and then to Mathematics with Statistics.\nI graduated in 2018 with a First Class (Honors) BSc in Mathematics with Statistics.\nDuring the COVID19 pandemic in 2020 I returned to Lancaster to obtain my MSc in Quantitative Finance.\nIn 2022 I began working towards my doctorate in Statistics and Applied Probability at UC Santa Barbara in California.\n\n\n\n\n\n\n\n\nflowchart TD\n  A(&lt;b&gt;BSc Mathematics with Statistics&lt;/b&gt; &lt;br&gt; Lancaster University &lt;br&gt; &lt;i&gt;2013-2018&lt;/i&gt;) --&gt; B(&lt;b&gt;MSc Quantitative Finance &lt;/b&gt; &lt;br&gt; Lancaster University &lt;br&gt; &lt;i&gt;2020-2021&lt;/i&gt;)\n  B --&gt; C(&lt;b&gt;Ph.D. Statistics and Applied Probability&lt;/b&gt; &lt;br&gt; UC Santa Barbara &lt;br&gt; &lt;i&gt;2022 - Present&lt;/i&gt;)"
  },
  {
    "objectID": "about.html#section",
    "href": "about.html#section",
    "title": "John Robin Inston",
    "section": "",
    "text": "Random walk simulation."
  },
  {
    "objectID": "about.html#areas",
    "href": "about.html#areas",
    "title": "John Robin Inston",
    "section": "Areas",
    "text": "Areas\n\n\nBlog\n\n\n\n\n\n\n\n\nFundamentals of Probability Theory\n\n\n\n\n\n\n\nNo matching items\n\n\nSee all →\n\n\nProjects\n\n\n\n\n\n\n\n\nImplementing Black Scholes and Vasiciek Models in R\n\n\n\n\n\n\n\nNo matching items\n\n\nSee all →\n\n\nCourses\n\n\n\n\n\n\n\n\nLinear Algebra\n\n\n\n\n\n\n\nNo matching items\n\n\nSee all →"
  },
  {
    "objectID": "courses/intro_to_data_science/index.html#course-information",
    "href": "courses/intro_to_data_science/index.html#course-information",
    "title": "Data Science with R",
    "section": "✏️ Course Information",
    "text": "✏️ Course Information\nWelcome to Data Science with R, a course providing an introduction on how to use the programming language R for data science and statistical modelling.\nThe aim of this course is to provide a thorough introduction to programming in R for individuals who may have never written or utilized a programming language before. First we outline how to install R on our operating system, how to download and use an Interactive Development Environment (IDE) such as RStudio, Positron or VSCode, and how to install packages on our system. We will then explore various ways to explore, manage and analyze data using both the in-built functionality in R as well as available libraries such as tidyverse."
  },
  {
    "objectID": "courses/intro_to_data_science/index.html#course-structure",
    "href": "courses/intro_to_data_science/index.html#course-structure",
    "title": "Data Science with R",
    "section": "✍️ Course Structure",
    "text": "✍️ Course Structure\nThis course is based fundamentally on the PSTAT10 Data Science Principles class I have taught in the past at UCSB. The course is split into the following topics:\n\nInstalling and using R and RStudio.\nR Basics I - Operators, Logic & Data Types.\nR Basics II - Atomic Data Structures.\nR Basics III - Dataframes and Lists\nR Basics IV - Functions\nR Basics V - Looping and Branching\nFundamentals of Probability Theory.\nBasic Simulation with R.\nData Handling with the tidyverse package.\nPlotting with ggplot2.\nSQL Basics.\nSQL Aggregation and Joins."
  },
  {
    "objectID": "courses/intro_to_data_science/index.html#course-materials",
    "href": "courses/intro_to_data_science/index.html#course-materials",
    "title": "Data Science with R",
    "section": "📚 Course Materials",
    "text": "📚 Course Materials\nEach topic links to a website post with the relevant material. A pdf copy of the combined course notes can be downloaded here. Furthermore, each wesite post links to the corresponding youtube video going through the material.\nFor this course you will need to download the language R, your chosen IDE and Quarto using the following links:\n\nLink to download R & RStudio\nLink to download Quarto\n\nSome helpful resources and additional guides and linked below:\n\nDocumentation: Quarto for PDF documents\nDocumentation: Writing maths using LaTeX\nDocumentation: Plotting with ggplot\n\nIf you found any of this material helpful consider buying me a coffee but only if you can afford to! Thank you for visiting this course page. 😊"
  },
  {
    "objectID": "posts/qualification/index.html",
    "href": "posts/qualification/index.html",
    "title": "Update: Qualified at last!",
    "section": "",
    "text": "Over the past few months I have been working to prepare and submit an initial research report as part of my departments qualification requirements. Thanks to guidance from my supervisor Dr Ludkovski and helpful discussions with my reviewer Dr Ichiba I am grateful to say my report has been accepted and I am now qualified to work towards my advancement.\nIt has been a lot of work these first few years riddled with set backs and challenges but it is rewarding to finally feel confident about my direction moving forward. I feel more focussed and driven now that I have a clear goal and a project to focus my attention on.\nFor any graduate student still working towards this milestone just keep moving forward. I have been overwhelmed by feelings of inadequacy and imposter’s syndrome being surrounded by so many brilliant and smart students but I have found it more important to maintain a positive work ethic and to embrace doggedly trying to consistently improve. You might never be the smartest student in the department but you can always strive to be smarter than your past self.\n\n\n\nImage taken by Zekai Wu, find him on instagram at @pipikai."
  },
  {
    "objectID": "posts/qualification/index.html#qualifying",
    "href": "posts/qualification/index.html#qualifying",
    "title": "Qualification",
    "section": "",
    "text": "This week was an important week for my PhD journey"
  },
  {
    "objectID": "posts/qualification/index.html#updates",
    "href": "posts/qualification/index.html#updates",
    "title": "Update: Qualified at last!",
    "section": "",
    "text": "Over the past few months I have been working to prepare and submit an initial research report as part of my departments qualification requirements. Thanks to guidance from my supervisor Dr Ludkovski and helpful discussions with my reviewer Dr Ichiba I am grateful to say my report has been accepted and I am now qualified to work towards my advancement.\nIt has been a lot of work these first few years riddled with set backs and challenges but it is rewarding to finally feel confident about my direction moving forward. I feel more focussed and driven now that I have a clear goal and a project to focus my attention on.\nFor any graduate student still working towards this milestone just keep moving forward. I have been overwhelmed by feelings of inadequacy and imposter’s syndrome being surrounded by so many brilliant and smart students but I have found it more important to maintain a positive work ethic and to embrace doggedly trying to consistently improve. You might never be the smartest student in the department but you can always strive to be smarter than your past self.\n\n\n\nImage taken by Zekai Wu, find him on instagram at @pipikai."
  },
  {
    "objectID": "posts/Rds1_installation/index.html",
    "href": "posts/Rds1_installation/index.html",
    "title": "Installing and using R and RStudio",
    "section": "",
    "text": "This post contains notes for Chapter 1 of my course series Data Science with R covering how to install both the language R and the IDE RStudio, and the basics of using the IDE for data analysis."
  },
  {
    "objectID": "posts/Rds1_installation/index.html#installation",
    "href": "posts/Rds1_installation/index.html#installation",
    "title": "Installing and using R and RStudio",
    "section": "Installation",
    "text": "Installation\nR is not natively loaded on your computer and so to begin with we need to install both the language and the IDE onto our computers, the downloads for which can be found on the posit website. You will need to check that you download versions of both R and RStudio that match your operating system.\n\n\n\nPosit website R and RStudio download screen.\n\n\nR will be loaded onto your local drive and can mostly be forgotten about. RStudio will be downloaded into your applications folder and once the download is complete you can open the application to get started."
  },
  {
    "objectID": "posts/Rds1_installation/index.html#background-information",
    "href": "posts/Rds1_installation/index.html#background-information",
    "title": "Installing and using R and RStudio",
    "section": "Background Information",
    "text": "Background Information\nR is a programming language (like python or C++) whilst RStudio is a software that facilitates writing R scripts known as an Intergrated Development Enviroment (IDE). In this course we will learn how to write in the R language using the IDE RStudio.\nR can be used to perform and automate computations, generate plots, simulate from random variables and perform statistical analysis. RStudio is primarily an R focussed IDE but it also has the capability of producing technical documents in a variety of formats using Quarto markdown. This is something I discuss in my post [insert post]."
  },
  {
    "objectID": "posts/Rds1_installation/index.html#rstudio-layout",
    "href": "posts/Rds1_installation/index.html#rstudio-layout",
    "title": "Installing and using R and RStudio",
    "section": "RStudio Layout",
    "text": "RStudio Layout\nWhen you first open RStudio the application will be split into several sections called panes, each with a selection of tabs.\n\n\n\nRStudio Layout.\n\n\nWe will first go through the most important tabs and what they are used for:\n\nLeft Pane:\n\nConsole Tab - Where R code can be read and executed by your computer.\nTerminal Tab - Providing command line access to the computer’s operating system (this is rarely used by beginners).\n\nUpper Right Pane:\n\nEnvironment Tab - A breakdown of items saved in the working memory.\n\nLower Right Pane:\n\nFiles Tab - A view of your system files.\nPlots Tab - A space displaying any plot you generate.\nPackages Tab - A manager to load functions defined by other users known as packages.\nHelp Tab - A space to search for and view code documentation."
  },
  {
    "objectID": "posts/Rds1_installation/index.html#system-vs-working-memory",
    "href": "posts/Rds1_installation/index.html#system-vs-working-memory",
    "title": "Installing and using R and RStudio",
    "section": "System vs Working Memory",
    "text": "System vs Working Memory\nAnytime you define something in R (discussed in a later chapter) it will be saved to RStudios working (short-term) memory, shown in the environment tab. The available memory is limited and it is important to remember that anything stored here will be deleted once you close RStudio.\nFor long term storage you will need to save objects to your system memory (your computers filing system), shown in the files tab. You will then be able to load anything you have saved for later use. In this course we will typically only use our system memory for saving our R scripts (text documents in which we write our code), accessing data files or for generating and saving .pdf documents.\nRStudios working environment is the file on your system that RStudio is currently looking within (i.e. what it can pull files from and save files too). The default working directory location is the file that is shown within the files tab. You can set a new working directory at anytime by either:\n\nNavigating to the desired folder in the files tab, clicking on the more settings cog and selecting Set as Working Directory.\nTyping setwd(\"desired_file_path\") into the R console.\n\nIn the image below you can see that I have created a folder titled Data Science with R in my system Documents folder and set this as my working directory.\n\n\n\nSet working directory,\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\nLets prepare to create our first R script. First navigate to your desired course folder (or create on) and set it as your working directory."
  },
  {
    "objectID": "posts/Rds1_installation/index.html#file-management-preparation",
    "href": "posts/Rds1_installation/index.html#file-management-preparation",
    "title": "Installing and using R and RStudio",
    "section": "File Management Preparation",
    "text": "File Management Preparation\nLets prepare to create our first"
  },
  {
    "objectID": "posts/Rds1_installation/index.html#creating-r-scripts",
    "href": "posts/Rds1_installation/index.html#creating-r-scripts",
    "title": "Installing and using R and RStudio",
    "section": "Creating R Scripts",
    "text": "Creating R Scripts\nNow we are ready to create our first R script by using any of the following methods:\n\nNavigate to file &gt; New File &gt; R Script;\nUse the shortcut shift + cmd + N on mac;\nClick the small + button at the top left of the application window and select R Script.\n\n\n\n\nCreating a new R Script.\n\n\nAfter this a new pane will appear in the top left position showing an unititled document with the suffix .R. We can save this file using either:\n\nThe shortcut CMD + S;\nClicking File &gt; Save,\n\nand the document should then appear in our working directory, therefore in our system storage.\n\n\n\nSaved script appearing in our working directory.\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nCreate and save your first R script (choose whatever name you like) to your working directory."
  },
  {
    "objectID": "posts/Rds1_installation/index.html#review",
    "href": "posts/Rds1_installation/index.html#review",
    "title": "Installing and using R and RStudio",
    "section": "Review",
    "text": "Review\nAt the end of this short lesson we should now be able to:\n\nDownload and install both R and RStudio.\nSet our working directory.\nCreate new R scripts and save them.\nInstall and load packages.\nUse the help function to search for documentation.\n\n\n  ← Course Homepage \n  Next Chapter →"
  },
  {
    "objectID": "posts/Rds2_rbasics/index.html",
    "href": "posts/Rds2_rbasics/index.html",
    "title": "R Basics I (Operators, Logic & Data Types)",
    "section": "",
    "text": "This post contains notes for Chapter 2 of my course series Data Science with R covering the basic use of R as a calculator including computations, logic, data types and the assignment operator."
  },
  {
    "objectID": "posts/Rds2_rbasics/index.html#operators",
    "href": "posts/Rds2_rbasics/index.html#operators",
    "title": "R Basics (Operations, Objects and Functions)",
    "section": "Operators",
    "text": "Operators\n\n  ← Previous Chapter \n  Next Chapter →"
  },
  {
    "objectID": "posts/Rds1_installation/index.html#packages",
    "href": "posts/Rds1_installation/index.html#packages",
    "title": "Installing and using R and RStudio",
    "section": "Packages",
    "text": "Packages\nR comes preloaded with a variety of functions, called base functions however there are many tasks for which they are insufficient (advanced plotting, statistical modelling etc.). CRAN Packages are collections of functions written in R by other users that are available for download. A comprehensive list of the available packages are detailed on the CRAN website.\nThroughout this course we will use a variety of packages (such as tidyverse) and so it is important we know how to load and use the in-built package management in RStudio. navigating to the packages tab we will see a list of pre-installed packages with empty check marks next to them. These packages are installed (downloaded from the internet) but not loaded (not available for use in our R session).\nTo install a package (e.g. tidyverse) we can use the install.packages() function where the input to the function is the name of the package enclosed in quotation marks:\n\ninstall.packages('tidyverse')\n\nYou will see the package appear with no check mark in the packages manager. Note that once a package is installed it will not need to be installed in future unless you reinstall RStudio (which is why we often omit this code in scripts).\nNext, to load a package we can use the library()function where this time the input is the name of the package with no quotation marks:\n\nlibrary(tidyverse)\n\nYour console output will often provide relevant information about the version of the package and its compatibility with your downloaded version of R and other loaded packages. Running this function will check the box next to tidyverse in the package tab.\nI recommend including all your package loading functions at the top of your script so you can quickly check what packages you have loaded in your session.\n\n\n\nPackage tab with loaded tidyverse package.\n\n\nOccasionally you might have loaded multiple packages which have conflicting package names. In this case, you may want to unload a package which you can do using the detach() function. The syntax for the input is a little more complicated:\n\ndetach(\"package:tidyverse\", unload = TRUE)\n\n\n\n\n\n\n\nExercise 3\n\n\n\nBy writing code in your console install the packages: (1) tidyverse; (2) astsa and (3) zoo, using the install.packages() function. Now in your script use the library() function to load all three packages."
  },
  {
    "objectID": "posts/Rds1_installation/index.html#help-function",
    "href": "posts/Rds1_installation/index.html#help-function",
    "title": "Installing and using R and RStudio",
    "section": "Help Function",
    "text": "Help Function\nOne of my most used functions in R is ? which quickly loads to documentation for the specified function in the Help tab. An example of using this function to return information about the base mean() function is:\n\n?mean()\n\nIf you run this code you will see the documentation for the mean() function displayed in the Help tab.\n\n\n\nHelp function output for mean() function.\n\n\n\n\n\n\n\n\nExercise 4\n\n\n\nIn the tidyverse function you have just loaded there is a function ggplot(). Use the help ? syntax to load and read the documentation."
  },
  {
    "objectID": "projects/vasiciek_model/index.html#the-black-scholes-model",
    "href": "projects/vasiciek_model/index.html#the-black-scholes-model",
    "title": "Implementing Black Scholes and Vasiciek Models in R",
    "section": "The Black-Scholes Model",
    "text": "The Black-Scholes Model\nThe price at time \\(t_0=0\\) of a European call option (‘ECO’) on a stock with strike price \\(c\\), expiry time \\(t_0\\), initial stock price \\(S_0\\), interest rate \\(\\rho\\) and volatility \\(\\sigma\\) is given by the Black-Scholes (‘BS’) formula. This is given below in Equation 1\n\\[\n\\begin{aligned}\nP_{t_0}=&S_0\\Phi\\left(\\frac{\\log(S_0/c)+(\\rho+\\sigma^2/2)t_0}{\\sigma\\sqrt{t_0}}\\right)\\\\\\\\ &-c\\exp(-\\rho t_0)\\Phi\\left(\\frac{\\log(S_0/c)+(\\rho-\\sigma^2/2)t_0}{\\sigma\\sqrt{t_0}}\\right)\n\\end{aligned}\\tag{1}\n\\]\nIn Figure 1 below we plot the price over time of the ECO, \\(P_t\\), for \\(0\\leq t\\leq 10\\) with \\(s_0=1\\), \\(\\sigma^2=0.02\\), \\(\\rho=0.03\\) and \\(c=1\\).\n\n# Define initial values\nS0 = 1 \nsigma = sqrt(0.02)\nrho = 0.03\nc = 1\nt = seq(0.001, 10, by=0.001)\n\n# Define price\nP = S0*pnorm((log(S0/c)+(rho+(sigma^2)/2)*t)/(sigma*sqrt(t)))-\n(c*exp(-rho*t))*pnorm((log(S0/c)+(rho-(sigma^2)/2)*t)/(sigma*sqrt(t)))\n\n# Produce plot\ndata.frame(\n    Price = P, \n    Time = t\n    ) |&gt;\n    ggplot(aes(Time, Price)) + \n    geom_line() + \n    labs(\n       y = \"Option price\",\n       x = \"Time\"\n    )\n\n\n\n\n\n\n\nFigure 1: European call option price over time as given by the Black-Scholes model.\n\n\n\n\n\nWe see that the price \\(P_t\\) is increasing over time, which makes sense as the values of the ECO should be dependent on the time the underlying stock has to increase in value. From Equation 1 we can see that \\(S_0\\) as \\(t\\rightarrow\\infty\\).\nWe plot the price \\(P_{10}\\) at time \\(t=10\\) as we vary each of \\(\\sigma\\), \\(\\rho\\) and \\(c\\) in turn. These are shown below in Figure 2, Figure 3 and Figure 4 respectively.\n\n# Fix time\nt10=10\n\n# Define varying sigma \nsigma1=seq(0,2, by=0.01)\n\n# Calculate new price series\nP1=S0*pnorm((log(S0/c)+(rho+(sigma1^2)/2)*t10)/(sigma1*sqrt(t10)))-\n(c*exp(-rho*t10))*pnorm((log(S0/c)+(rho-(sigma1^2)/2)*t10)/(sigma1*sqrt(t10)))\n\n# Produce plot\ndata.frame(\n    Price = P1, \n    Volatility = sigma1\n    ) |&gt; \n    ggplot(aes(sigma1,P1)) + \n    geom_line() + \n    labs(\n        y = \"Option price at time t=10\",\n        x = \"Volatility\"\n    )\n\n\n\n\n\n\n\nFigure 2: European call option price at fixed time \\(t=10\\) for various volatility values as given by the Black-Scholes model.\n\n\n\n\n\n\n# define varying rho\nrho2=seq(0, 0.8, by=0.005) \n\n# calculate new price series\nP2=S0*pnorm((log(S0/c)+(rho2+(sigma^2)/2)*t10)/(sigma*sqrt(t10)))-\n(c*exp(-rho2*t10))*pnorm((log(S0/c)+(rho2-(sigma^2)/2)*t10)/(sigma*sqrt(t10)))\n\n# produce plot for figure 3\ndata.frame(\n    Price = P2, \n    Interest = rho2\n    ) |&gt; ggplot(aes(Interest, Price)) +\n        geom_line() + \n        labs(\n            y = \"Option price at time t=10.\",\n            x = \"Interest Rate\"\n        )\n\n\n\n\n\n\n\nFigure 3: European call option price at fixed time \\(t=10\\) for various interest rates as given by the Black-Scholes model.\n\n\n\n\n\n\n# define varying c\nc3=seq(0,5, by=0.01)\n\n# calculate new price series\nP3=S0*pnorm((log(S0/c3)+(rho+(sigma^2)/2)*t10)/(sigma*sqrt(t10)))-\n(c3*exp(-rho*t10))*pnorm((log(S0/c3)+(rho-(sigma^2)/2)*t10)/(sigma*sqrt(t10)))\n\n# produce plot for figure 4\ndata.frame(\n    Price = P3, \n    Strike = c3\n) |&gt;\n    ggplot(aes(Strike, Price)) +\n    geom_line() + \n    labs(\n        x = \"Strike Price\",\n        y = \"Option Price\"\n    )\n\n\n\n\n\n\n\nFigure 4: European call option price at fixed time \\(t=10\\) for various strike prices as given by the Black-Scholes model.\n\n\n\n\n\nAs both volatility \\(\\sigma\\) and interest rates \\(\\rho\\) increase we see that \\(P_{10}\\rightarrow S_0\\). This is because high underlying stock volatility and interest rates both increase the potential option return which increases the options value up to the initial price of the stock. The option value is limited to this value because if the option price were to rise above the stock price then there would be no reason for investors to purchase the option rather than the stock.\nAs the strike price \\(c\\) increases we see that \\(P_{10}\\rightarrow 0\\). This is because if the option has a high strike price it is less likely that the underlying stock will reach this price during the period of the option which makes the option less valuable."
  },
  {
    "objectID": "projects/vasiciek_model/index.html#ornstein-uhlenbeck-processes",
    "href": "projects/vasiciek_model/index.html#ornstein-uhlenbeck-processes",
    "title": "Implementing Black Scholes and Vasiciek Models in R",
    "section": "Ornstein-Uhlenbeck Processes",
    "text": "Ornstein-Uhlenbeck Processes\nThe spot-rate \\(\\{R_s:s&gt;0\\}\\) is an Ornstein-Uhlenbeck (OU) process - with initial spot rate \\(R_0\\), long-term mean \\(\\mu\\) and reversion speed \\(\\theta&gt;0\\). This is given by Equation 2 below.\n\\[\nR_s=e^{-\\theta s}R_0+(1-e^{-\\theta s})\\mu+ X_s\\;. \\tag{2}\n\\]\nHere, \\(X_s\\) is an OU process with volatility \\(\\sigma&gt;0\\) and reversion parameter \\(\\theta&gt;0\\). This is equivalent to stating the following.\n\\[\n\\begin{aligned}\nE[X_s]&=0 \\\\\\\\ Cov(X_s, X_t)&=\\frac{\\sigma^2}{2\\theta}e^{-\\theta(s+t)}e^{2\\theta\\min(s, t)-1}\n\\end{aligned}\\tag{3}\n\\]\nWe begin by simulating the OU process \\(\\{X_s:s&gt;0\\}\\) with \\(\\theta = 0.5\\) and \\(\\sigma=0.02\\), shown below in Figure 5.\n\n## define the OU function\nrOU=function(n,N,Delta,theta,sigma){ \n  times=(0:n)*Delta ##vector of t_0,t_1,..,t_n \n  X=matrix(0,nrow=N,ncol=n+1)\n  for(i in 1:n){\n    x=X[,i]#current value\n    m=x*exp(-theta*Delta) #mean of new value \n    v=sigma^2*(1-exp(-2*theta*Delta))/(2*theta) ##variance of new value \n    X[,i+1]=rnorm(N,m,sqrt(v)) ##simulate new value\n  }\n  return(list(X=X,times=times)) \n}\n\n# define initial conditions \nn=10000\nN=10\nDelta=10/n\ntheta=0.5\nsigma=0.02\n\n# calculate 10 realizations of the OU process using our function\nOU=rOU(n, N, Delta, theta, sigma)\n\n# produce plot for Figure 5\ntX = data.frame(t(OU$X))\nOUfig = data.frame(x=seq_along(tX[,1]), tX)\nOUfig = melt(OUfig, id.vars = \"x\")\ncols = 2:11\nggplot(OUfig, aes(x = x, y = value, color = variable)) +\n  geom_line()+\n  xlab(\"Time (s)\") + ylab(\"OU process (X)\")+\n  guides(color = guide_legend(title = \"Simulation\"))+\n  scale_color_manual(values = cols)\n\n\n\n\n\n\n\nFigure 5: Simulation of OU process.\n\n\n\n\n\nUsing our results we simulate the OU process \\(\\{R_s:0\\leq s\\leq 10\\}\\) for \\(R_0=0.1\\), \\(\\theta=0.5\\), \\(\\mu=0.05\\) and \\(\\sigma=0.02\\) and produce a plot of our results. These are shown below in Figure 6.\n\n# define transformation conditions\nR0=0.1\nmu=0.05\n\n# transform OU process\nR=matrix(0, nrow=N, ncol=n+1)\nfor(i in 1:N){\n  R[i,]=exp(-theta*OU$times)*R0+(1-exp(-theta*OU$times))*mu+OU$X[i,]\n}\n\n# produce plot\ntR = data.frame(t(R))\nfig5 &lt;- data.frame(x = seq_along(tR[, 1]), tR)\nfig5 &lt;- melt(fig5, id.vars = \"x\")\ncols = 2:11\nplot5 = ggplot(fig5, aes(x = x, y = value, color = variable)) +\n  geom_line() +\n  xlab(\"Time (t)\") + ylab(\"Spot Rate (R)\")+\n  guides(color = guide_legend(title = \"Simulation\"))+\n  scale_color_manual(values = cols)\nplot5\n\n\n\n\n\n\n\nFigure 6: Simulation of spot rate OU process.\n\n\n\n\n\nThe expressions for the mean and variance of this process are given by:\n\\[\n\\begin{aligned}\n\\mathbb{E}[R_s] & =e^{-\\theta s}R_0+(1+e^{-\\theta s})\\mu,\\\\\n\\text{Var}[R_s] & =\\frac{\\sigma^2}{2\\theta}(1-e^{-s\\theta s})\n\\end{aligned}\\tag{4}\n\\]\nWe plot the mean \\(E[R_s]\\) and variance \\(V[R_s]\\) against time in Figure 7 and Figure 8 below.\n\n# calculate the expectation\nexpRt=exp(-theta*OU$times)*R0+(1-exp(-theta*OU$times))*mu\n# expectation plot\nfig6 = data.frame(expRt, OU$times)\nggplot(data = fig6, aes(OU.times,expRt))+geom_line() + \n  xlab(\"Time\") + ylab(\"Expectated Value\")\n\n\n\n\n\n\n\nFigure 7: Simulated spot rate mean over time.\n\n\n\n\n\n\n# calculate the variance\nvarRt=(sigma^2/(2*theta))*(1-exp(-2*theta*OU$times))\n# variance plot\nfig7 = data.frame(varRt, OU$times)\nggplot(data = fig7, aes(OU.times, varRt))+geom_line() + \n  xlab(\"Time\") + ylab(\"Variance\")\n\n\n\n\n\n\n\nFigure 8: Simulated spot rate variance over time.\n\n\n\n\n\nWe evaluate what the mean and variance tend to as \\(s\\rightarrow\\infty\\), for which we obtain the following expressions:\n\\[\n\\begin{aligned}\n\\lim_{(s\\rightarrow\\infty)}\\{E[R_s]\\}&=\\mu\\\\\n\\lim_{(s\\rightarrow\\infty)}\\{V[R_s]\\}&=\\frac{\\sigma^2}{2\\theta}.\n\\end{aligned}\\tag{5}\n\\]\nWe can see from Figure 6 that the expectation is tending towards the long-term mean \\(\\mu=0.05\\) as expected. We can also see from Figure 8 that the variance is tending towards 0.04, which is as expected per our expression for the limit of \\(V[R_s]\\) as \\(s\\rightarrow\\infty\\).\nIf we change the value of \\(R_0\\) we will change the starting point of the process. If we change the value of \\(\\mu\\) we change the value which the expectation of the process will tend towards. If we increase the value of the reversion parameter \\(\\theta\\) only, we will decrease the value that the variance of the process will tend towards. Similarly, if we increase the value of the volatility \\(\\sigma\\) only, we will increase the value that the variance of the process will tend towards."
  },
  {
    "objectID": "projects/vasiciek_model/index.html#the-vasicek-model",
    "href": "projects/vasiciek_model/index.html#the-vasicek-model",
    "title": "Implementing Black Scholes and Vasiciek Models in R",
    "section": "The Vasicek Model",
    "text": "The Vasicek Model\nThe Vasicek model (first defined in article Vasicek(1977) and expanded in Burgess(2014)) defines the price \\(Q_t\\) at time 0 of a bond paying one unit at time \\(t\\). as:\n\\[\nQ_t=\\exp\\left(-\\int_0^t R_sds\\right),\\tag{6}\n\\]\nwhere \\(R_s\\) is the OU process defined previously. We plot 10 simulations of the bond price \\(Q_t\\) at time 0 of a bond paying one unit at time \\(t\\) for \\(R_0=0.1\\), \\(\\theta=0.5\\), \\(\\mu=0.05\\) and \\(\\sigma=0.02\\). These are shown below in Figure 9.\n\n# define matrix to store Q\nQ=matrix(0,nrow=N,ncol=n+1) \n# loop to generate values of Q\nfor(i in 1:N){\n  Q[i,]=exp(-Delta*cumsum(R[i,]))\n}\n\n# plot bond price over time\ntQ = data.frame(t(Q))\nfig8 &lt;- data.frame(x = seq_along(tQ[,1]),tQ)\nfig8 &lt;- melt(fig8, id.vars = \"x\")\ncols = 2:11\nggplot(fig8, aes(x = x, y = value, color = variable)) +\n  geom_line()+\n  xlab(\"Time (t)\") + ylab(\"Bond Price (Qt)\")+\n  guides(color = guide_legend(title = \"Simulation\"))+\n  scale_color_manual(values = cols)\n\n\n\n\n\n\n\nFigure 9: Simulated bond price over time.\n\n\n\n\n\nWe expect the distribution of \\(Q_t\\) to be log-normal as the integral \\(\\int_0^t R_s\\) is normal - as it is a linear combination of normal random variables. We can check the distribution of \\(Q_t\\) for the fixed value of \\(t=0\\) by simulating 1000 realizations of \\(\\log(1_{10})\\) and approximating their empirical distribution using a histogram - shown in Figure 10 below. From this histogram we can see that the distribution of \\(\\log(Q_{t})\\) appears to show the characteristic bell curve shape we would expect.\n\n# simulate 1000 realizations of Rt at t=10 (n=1000, delta=10/n so t=n*delta=10)\nN1=1000\nOU1=rOU(n, N1, Delta, theta, sigma)\n# define results matrix\nR1=matrix(0, nrow=N1, ncol=n+1)\n# loop to calculate results\nfor(i in 1:N1){\n  R1[i,]=exp(-theta*OU1$times)*R0+(1-exp(-theta*OU1$times))*mu+OU1$X[i,]\n}\n# calculating Q\nQ=rep(0, N1)\nfor(i in 1:N1){\n  Q[i]=exp(-Delta*sum(R1[i, 2:(n+1)]))\n}\n# produce plot\nfig9 = data.frame(Q, N1)\nggplot(data = fig9, aes(x=Q))+ geom_histogram(bins=30)+\n  xlab(\"log(Q)\") + ylab(\"Frequency\")\n\n\n\n\n\n\n\nFigure 10: Histogram of simulated log bond price.\n\n\n\n\n\nWe can evidence this further by using a Q-Q plot to compare the empirical distribution we have simulated with the normal distribution - shown in Figure 11 below. From this plot we see clear evidence that the distribution is normal due to the linearity of the points generated.\n\n# produce Q-Q plot\nplot10 = ggplot(fig9, aes(sample=Q))+stat_qq()\nplot10\n\n\n\n\n\n\n\nFigure 11: Q-Q plot of simulated log bond price."
  },
  {
    "objectID": "projects/vasiciek_model/index.html#conclusion",
    "href": "projects/vasiciek_model/index.html#conclusion",
    "title": "Implementing Black Scholes and Vasiciek Models in R",
    "section": "Conclusion",
    "text": "Conclusion\nBoth models discussed in this project come with several limitations. Firstly, the Black- Scholes model assumes that an option can only be exercised at expiration which limits its use to European options (as US options can be exercised before expiration). The model also makes assumptions that do not tend to hold in real world applications such as that no dividends are paid out during the life of the option, that markets are efficient, that there are no transaction costs in buying the option, that the risk-free rate and volatility of the underlying assets are known and constant and that the returns on the underlying assets are known and constant.\nThe main disadvantage of the Vasicek model that has come to light since the global financial crisis is that the model does not allow for interest rates to dip below zero and become negative. This issue has been fixed in several models that have been developed since the Vasicek model such as the exponential Vasicek model and the Cox-Ingersoll-Ross model for estimating interest rate changes and further investigation into these models would be a useful topic of further research."
  },
  {
    "objectID": "posts/Rds2_rbasics/index.html#calculations",
    "href": "posts/Rds2_rbasics/index.html#calculations",
    "title": "R Basics I (Operators, Logic & Data Types)",
    "section": "Calculations",
    "text": "Calculations\nWe can perform a wide variety of mathematical calculations using R including:\n\nMultiplication, addition, division, subtraction;\nRaising to powers and square rooting;\nTrigonometric functions;\nExponential and logarithmic functions.\n\nThe syntax to apply these operations is often very intuitive but slightly different to the mathematical notation.\n\nAddition, Subtraction, Multiplication and Division\n\n# Addition\n21 + 47 \n\n[1] 68\n\n# Subtraction\n456 - 564 \n\n[1] -108\n\n# Multiplication\n7*23      \n\n[1] 161\n\n# Division\n45/23     \n\n[1] 1.956522\n\n\n\n\nPowers and Square Roots\nTo raise numbers to powers we can use the ^ symbol. Note that if we wish to raise numbers to fractional powers we must ensure to enclose our fraction in parentheses (). Further, there is a specifically defined function for computing the square root of a number sqrt().\n\n\n\n\n\n\nImportant\n\n\n\nParentheses (), brackets [] and braces {} all have different uses in R and care should be taken to apply them correctly.\n\n\n\n# Powers \n9^2\n\n[1] 81\n\n# Fractional Powers\n225^(1/2)\n\n[1] 15\n\n# Square Root Function\nsqrt(225)\n\n[1] 15\n\n\n\n\nLogarithms and Exponentials\nAs a quick reminder in mathematics we define the irrational number \\(e\\) by \\[\ne = 2.71828...\n\\]\nThe exponential function \\(\\exp(\\cdot)\\) is defined as \\[\n\\exp(x) = e^x.\n\\]\nThe inverse of this function is known as the natural logarithm \\(\\log(\\cdot)=\\ln(\\cdot)\\) and is defined as the power of which \\(e\\) will have to be raised to in order to give \\(x\\). It is therefore the inverse of the exponential function and satisfies \\[\n\\exp(\\log(x)) = e^{\\log(x)} = x.\n\\]\nFor a more indepth look at these functions and the results we use to perform calculations with them see my note on Log Laws. To apply these functions in R we use the exp() and log() functions:\n\n# Exponential function\nexp(1)\n\n[1] 2.718282\n\nexp(17)\n\n[1] 24154953\n\n# Log function\nlog(47)\n\n[1] 3.850148\n\n# Inverse example\nlog(exp(47))\n\n[1] 47\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\nVerify the following mathematical computations in R using the operations above:\n\n\\(\\left(\\frac{\\log(49^2)}{\\exp(4)}\\right)^{1/3}=0.5223981\\);\n\\(\\left(67+\\left(\\frac{12}{5} \\times \\frac{3}{12}\\right)\\right)^e+\\left(\\log(21) - \\sqrt{14}\\right)=94255.7\\)"
  },
  {
    "objectID": "posts/Rds2_rbasics/index.html#assignment-operator",
    "href": "posts/Rds2_rbasics/index.html#assignment-operator",
    "title": "R Basics I (Operators, Logic & Data Types)",
    "section": "Assignment Operator",
    "text": "Assignment Operator\nThe assignment operator -&gt; is used to define objects in R. Objects can take many different forms from basic numbers to vectors, matrices or even functions, all of which we will cover in future sections. For now, suppose we wish to store the results of some of the above computations for future use. We can do so by applying the assignment oeprator:\n\n# Define object a\na &lt;- (log(49^2)/exp(4))^(1/3)\n\nRunning this code you should see the object a appear in your environment tab and you might have noticed no result was printed in the console. To print the value of a in your console you can either use the print() function or just call the object in your console:\n\n# Print function\nprint(a)\n\n[1] 0.5223981\n\n# Call Object\na\n\n[1] 0.5223981\n\n\n\n  ← Previous Chapter \n  Next Chapter →"
  },
  {
    "objectID": "posts/Rds2_rbasics/index.html#vectors",
    "href": "posts/Rds2_rbasics/index.html#vectors",
    "title": "R Basics I (Operators, Logic, Data Types and Functions)",
    "section": "Vectors",
    "text": "Vectors\n\n  ← Previous Chapter \n  Next Chapter →"
  },
  {
    "objectID": "posts/Rds2_rbasics/index.html#logic",
    "href": "posts/Rds2_rbasics/index.html#logic",
    "title": "R Basics I (Operators, Logic & Data Types)",
    "section": "Logic",
    "text": "Logic\nR can also handle logical inputs including:\n\n&lt; less than;\n&lt;= less than or equal to;\n&gt; greater than;\n&gt;= greater than or equal to;\n== equal to;\n!= not equal to;\n& AND (\\(\\cap\\) written mathematically);\n| OR (\\(\\cup\\) written mathematically).\n\nWe can write a logical expression and the return will note whether the statement was true or false. For example, the output below is FALSE because the statement “4 is greater than or equal to 5” is false:\n\n# Logical example\n4 &gt;= 5\n\n[1] FALSE\n\n\nNote that to combine logical expressions we must use & or |! For example, trying to evaluate 2 &lt; 4 &lt; 5 will result in an error message."
  },
  {
    "objectID": "posts/Rds2_rbasics/index.html#data-types",
    "href": "posts/Rds2_rbasics/index.html#data-types",
    "title": "R Basics I (Operators, Logic & Data Types)",
    "section": "Data Types",
    "text": "Data Types\nIf we were to save the output of the previous logical expression to an object b we would see in our environment tab that b is a boolean type. R has the capacity to handle multiple data types including:\n\nNumeric - scalar numbers, vectors, matrices;\nBoolean / Logical - TRUE / FALSE output of some logical query;\nCharacter - Any number or character enclosed in '' or \"\".\n\nA sequential collection of characters forms a string e.g. \"datascience\" but note that this is not a specific datatype in R.\n\n\n\n\n\n\nExercise 2\n\n\n\nWhat will the following logical queries output:\n\n5 &gt; 7\n10 &lt;= 10\n13 != 12\n\"Hello\" &gt;= \"Hell\"\n\"Hello\" != \"Hell\" | 5 &lt; 4\n3 &lt; 5 &lt; 7"
  },
  {
    "objectID": "posts/r_data_science_2/index.html",
    "href": "posts/r_data_science_2/index.html",
    "title": "R Basics I (Operators, Logic & Data Types)",
    "section": "",
    "text": "This post contains notes for Chapter 2 of my course series Data Science with R covering the basic use of R as a calculator including computations, logic, data types and the assignment operator."
  },
  {
    "objectID": "posts/r_data_science_2/index.html#calculations",
    "href": "posts/r_data_science_2/index.html#calculations",
    "title": "R Basics I (Operators, Logic & Data Types)",
    "section": "Calculations",
    "text": "Calculations\nWe can perform a wide variety of mathematical calculations using R including:\n\nMultiplication, addition, division, subtraction;\nRaising to powers and square rooting;\nTrigonometric functions;\nExponential and logarithmic functions.\n\nThe syntax to apply these operations is often very intuitive but slightly different to the mathematical notation. Note that all computations written in R follow the BIDMAS (Brackets, Indices, Division, Multiplication, Addition, Subtraction) order of operations rule and so take care to ensure clarity with parentheses if necessary.\n\nAddition, Subtraction, Multiplication and Division\n\n# Addition\n21 + 47 \n\n[1] 68\n\n# Subtraction\n456 - 564 \n\n[1] -108\n\n# Multiplication\n7*23      \n\n[1] 161\n\n# Division\n45/23     \n\n[1] 1.956522\n\n\n\n\nPowers and Square Roots\nTo raise numbers to powers we can use the ^ symbol. Note that if we wish to raise numbers to fractional powers we must ensure to enclose our fraction in parentheses (). Further, there is a specifically defined function for computing the square root of a number sqrt().\n\n\n\n\n\n\nImportant\n\n\n\nParentheses (), brackets [] and braces {} all have different uses in R and care should be taken to apply them correctly.\n\n\n\n# Powers \n9^2\n\n[1] 81\n\n# Fractional Powers\n225^(1/2)\n\n[1] 15\n\n# Square Root Function\nsqrt(225)\n\n[1] 15\n\n\n\n\nLogarithms and Exponentials\nAs a quick reminder in mathematics we define the irrational number \\(e\\) by \\[\ne = 2.71828...\n\\]\nThe exponential function \\(\\exp(\\cdot)\\) is defined as \\[\n\\exp(x) = e^x.\n\\]\nThe inverse of this function is known as the natural logarithm \\(\\log(\\cdot)=\\ln(\\cdot)\\) and is defined as the power of which \\(e\\) will have to be raised to in order to give \\(x\\). It is therefore the inverse of the exponential function and satisfies \\[\n\\exp(\\log(x)) = e^{\\log(x)} = x.\n\\]\nFor a more indepth look at these functions and the results we use to perform calculations with them see my note on Log Laws. To apply these functions in R we use the exp() and log() functions:\n\n# Exponential function\nexp(1)\n\n[1] 2.718282\n\nexp(17)\n\n[1] 24154953\n\n# Log function\nlog(47)\n\n[1] 3.850148\n\n# Inverse example\nlog(exp(47))\n\n[1] 47\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\nVerify the following mathematical computations in R using the operations above:\n\n\\(\\left(\\frac{\\log(49^2)}{\\exp(4)}\\right)^{1/3}=0.5223981\\);\n\\(\\left(67+\\left(\\frac{12}{5} \\times \\frac{3}{12}\\right)\\right)^e+\\left(\\log(21) - \\sqrt{14}\\right)=94255.7\\)"
  },
  {
    "objectID": "posts/r_data_science_2/index.html#logic",
    "href": "posts/r_data_science_2/index.html#logic",
    "title": "R Basics I (Operators, Logic & Data Types)",
    "section": "Logic",
    "text": "Logic\nR can also handle logical inputs including:\n\n&lt; less than;\n&lt;= less than or equal to;\n&gt; greater than;\n&gt;= greater than or equal to;\n== equal to;\n!= not equal to;\n& AND (\\(\\cap\\) written mathematically);\n| OR (\\(\\cup\\) written mathematically).\n\nWe can write a logical expression and the return will note whether the statement was true or false. For example, the output below is FALSE because the statement “4 is greater than or equal to 5” is false:\n\n# Logical example\n4 &gt;= 5\n\n[1] FALSE\n\n\nNote that to combine logical expressions we must use & or |! For example, trying to evaluate 2 &lt; 4 &lt; 5 will result in an error message."
  },
  {
    "objectID": "posts/r_data_science_2/index.html#data-types",
    "href": "posts/r_data_science_2/index.html#data-types",
    "title": "R Basics I (Operators, Logic & Data Types)",
    "section": "Data Types",
    "text": "Data Types\nIf we were to save the output of the previous logical expression to an object b we would see in our environment tab that b is a boolean type. R has the capacity to handle multiple data types including:\n\nNumeric - split into two sub-categories:\n\nInteger - integer values i.e. whole numbers;\nDouble - decimal values (default over integer);\n\nBoolean / Logical - TRUE / FALSE output of some logical query;\nCharacter - Any number or character enclosed in '' or \"\".\n\nA sequential collection of characters forms a string e.g. \"datascience\" but note that this is not a specific datatype in R unlike other languages such as python.\n\n\n\n\n\n\nExercise 2\n\n\n\nWhat will the following logical queries output:\n\n5 &gt; 7\n10 &lt;= 10\n13 != 12\n\"Hello\" &gt;= \"Hell\"\n\"Hello\" != \"Hell\" | 5 &lt; 4\n3 &lt; 5 &lt; 7"
  },
  {
    "objectID": "posts/r_data_science_2/index.html#assignment-operator",
    "href": "posts/r_data_science_2/index.html#assignment-operator",
    "title": "R Basics I (Operators, Logic & Data Types)",
    "section": "Assignment Operator",
    "text": "Assignment Operator\nThe assignment operator -&gt; is used to define objects in R, i.e. to store them in our short-term memory to use multiple times. Objects can take many different forms from basic numbers to vectors, matrices or even functions, all of which we detail in Chapter 3. For now, suppose we wish to store the results of some of the above computations for future use. We can do so by applying the assignment oeprator:\n\n# Define object a\na &lt;- (log(49^2)/exp(4))^(1/3)\n\nRunning this code you should see the object a appear in your environment tab and you might have noticed no result was printed in the console. To print the value of a in your console you can either use the print() function or just call the object in your console:\n\n# Print function\nprint(a)\n\n[1] 0.5223981\n\n# Call Object\na\n\n[1] 0.5223981\n\n\n\n  ← Previous Chapter \n  Next Chapter →"
  },
  {
    "objectID": "posts/r_data_science_1/index.html",
    "href": "posts/r_data_science_1/index.html",
    "title": "Installing and using R and RStudio",
    "section": "",
    "text": "This post contains notes for Chapter 1 of my course series Data Science with R covering how to install both the language R and the IDE RStudio, and the basics of using the IDE for data analysis."
  },
  {
    "objectID": "posts/r_data_science_1/index.html#background-information",
    "href": "posts/r_data_science_1/index.html#background-information",
    "title": "Installing and using R and RStudio",
    "section": "Background Information",
    "text": "Background Information\nR is a programming language (like python or C++) whilst RStudio is a software that facilitates writing R scripts known as an Intergrated Development Enviroment (IDE). In this course we will learn how to write in the R language using the IDE RStudio.\nR can be used to perform and automate computations, generate plots, simulate from random variables and perform statistical analysis. RStudio is primarily an R focussed IDE but it also has the capability of producing technical documents in a variety of formats using Quarto markdown. You can find some fabulous online documentation about the capabilities of Quarto markdown documents here."
  },
  {
    "objectID": "posts/r_data_science_1/index.html#installation",
    "href": "posts/r_data_science_1/index.html#installation",
    "title": "Installing and using R and RStudio",
    "section": "Installation",
    "text": "Installation\nR is not natively loaded on your computer and so to begin with we need to install both the language and the IDE onto our computers, the downloads for which can be found on the posit website. You will need to check that you download versions of both R and RStudio that match your operating system.\n\n\n\nPosit website R and RStudio download screen.\n\n\nR will be loaded onto your local drive and can mostly be forgotten about. RStudio will be downloaded into your applications folder and once the download is complete you can open the application to get started."
  },
  {
    "objectID": "posts/r_data_science_1/index.html#rstudio-layout",
    "href": "posts/r_data_science_1/index.html#rstudio-layout",
    "title": "Installing and using R and RStudio",
    "section": "RStudio Layout",
    "text": "RStudio Layout\nWhen you first open RStudio the application will be split into several sections called panes, each with a selection of tabs.\n\n\n\nRStudio Layout.\n\n\nWe will first go through the most important tabs and what they are used for:\n\nLeft Pane:\n\nConsole Tab - Where R code can be read and executed by your computer.\nTerminal Tab - Providing command line access to the computer’s operating system (this is rarely used by beginners).\n\nUpper Right Pane:\n\nEnvironment Tab - A breakdown of items saved in the working memory.\n\nLower Right Pane:\n\nFiles Tab - A view of your system files.\nPlots Tab - A space displaying any plot you generate.\nPackages Tab - A manager to load functions defined by other users known as packages.\nHelp Tab - A space to search for and view code documentation."
  },
  {
    "objectID": "posts/r_data_science_1/index.html#system-vs-working-memory",
    "href": "posts/r_data_science_1/index.html#system-vs-working-memory",
    "title": "Installing and using R and RStudio",
    "section": "System vs Working Memory",
    "text": "System vs Working Memory\nAnytime you define something in R (discussed in a later chapter) it will be saved to RStudios working (short-term) memory, shown in the environment tab. The available memory is limited and it is important to remember that anything stored here will be deleted once you close RStudio.\nFor long term storage you will need to save objects to your system memory (your computers filing system), shown in the files tab. You will then be able to load anything you have saved for later use. In this course we will typically only use our system memory for saving our R scripts (text documents in which we write our code), accessing data files or for generating and saving .pdf documents.\nRStudios working environment is the file on your system that RStudio is currently looking within (i.e. what it can pull files from and save files too). The default working directory location is the file that is shown within the files tab. You can set a new working directory at anytime by either:\n\nNavigating to the desired folder in the files tab, clicking on the more settings cog and selecting Set as Working Directory.\nTyping setwd(\"desired_file_path\") into the R console.\n\nIn the image below you can see that I have created a folder titled Data Science with R in my system Documents folder and set this as my working directory.\n\n\n\nSet working directory,\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\nLets prepare to create our first R script. First navigate to your desired course folder (or create on) and set it as your working directory."
  },
  {
    "objectID": "posts/r_data_science_1/index.html#creating-r-scripts",
    "href": "posts/r_data_science_1/index.html#creating-r-scripts",
    "title": "Installing and using R and RStudio",
    "section": "Creating R Scripts",
    "text": "Creating R Scripts\nNow we are ready to create our first R script by using any of the following methods:\n\nNavigate to file &gt; New File &gt; R Script;\nUse the shortcut shift + cmd + N on mac;\nClick the small + button at the top left of the application window and select R Script.\n\n\n\n\nCreating a new R Script.\n\n\nAfter this a new pane will appear in the top left position showing an unititled document with the suffix .R. We can save this file using either:\n\nThe shortcut CMD + S;\nClicking File &gt; Save,\n\nand the document should then appear in our working directory, therefore in our system storage.\n\n\n\nSaved script appearing in our working directory.\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nCreate and save your first R script (choose whatever name you like) to your working directory."
  },
  {
    "objectID": "posts/r_data_science_1/index.html#packages",
    "href": "posts/r_data_science_1/index.html#packages",
    "title": "Installing and using R and RStudio",
    "section": "Packages",
    "text": "Packages\nR comes preloaded with a variety of functions, called base functions however there are many tasks for which they are insufficient (advanced plotting, statistical modelling etc.). CRAN Packages are collections of functions written in R by other users that are available for download. A comprehensive list of the available packages are detailed on the CRAN website.\nThroughout this course we will use a variety of packages (such as tidyverse) and so it is important we know how to load and use the in-built package management in RStudio. navigating to the packages tab we will see a list of pre-installed packages with empty check marks next to them. These packages are installed (downloaded from the internet) but not loaded (not available for use in our R session).\nTo install a package (e.g. tidyverse) we can use the install.packages() function where the input to the function is the name of the package enclosed in quotation marks:\n\ninstall.packages('tidyverse')\n\nYou will see the package appear with no check mark in the packages manager. Note that once a package is installed it will not need to be installed in future unless you reinstall RStudio (which is why we often omit this code in scripts).\nNext, to load a package we can use the library()function where this time the input is the name of the package with no quotation marks:\n\nlibrary(tidyverse)\n\nYour console output will often provide relevant information about the version of the package and its compatibility with your downloaded version of R and other loaded packages. Running this function will check the box next to tidyverse in the package tab.\nI recommend including all your package loading functions at the top of your script so you can quickly check what packages you have loaded in your session.\n\n\n\nPackage tab with loaded tidyverse package.\n\n\nOccasionally you might have loaded multiple packages which have conflicting package names. In this case, you may want to unload a package which you can do using the detach() function. The syntax for the input is a little more complicated:\n\ndetach(\"package:tidyverse\", unload = TRUE)\n\n\n\n\n\n\n\nExercise 3\n\n\n\nBy writing code in your console install the packages: (1) tidyverse; (2) astsa and (3) zoo, using the install.packages() function. Now in your script use the library() function to load all three packages."
  },
  {
    "objectID": "posts/r_data_science_1/index.html#help-function",
    "href": "posts/r_data_science_1/index.html#help-function",
    "title": "Installing and using R and RStudio",
    "section": "Help Function",
    "text": "Help Function\nOne of my most used functions in R is ? which quickly loads to documentation for the specified function in the Help tab. An example of using this function to return information about the base mean() function is:\n\n?mean()\n\nIf you run this code you will see the documentation for the mean() function displayed in the Help tab.\n\n\n\nHelp function output for mean() function.\n\n\n\n\n\n\n\n\nExercise 4\n\n\n\nIn the tidyverse function you have just loaded there is a function ggplot(). Use the help ? syntax to load and read the documentation."
  },
  {
    "objectID": "posts/r_data_science_1/index.html#review",
    "href": "posts/r_data_science_1/index.html#review",
    "title": "Installing and using R and RStudio",
    "section": "Review",
    "text": "Review\nAt the end of this short lesson we should now be able to:\n\nDownload and install both R and RStudio.\nSet our working directory.\nCreate new R scripts and save them.\nInstall and load packages.\nUse the help function to search for documentation.\n\n\n  ← Course Homepage \n  Next Chapter →"
  },
  {
    "objectID": "posts/r_data_science_3/index.html",
    "href": "posts/r_data_science_3/index.html",
    "title": "R Basics II (Atomic Data Structures)",
    "section": "",
    "text": "This post contains notes for Chapter 3 of my course series Data Science with R covering atomic data structures."
  },
  {
    "objectID": "posts/r_data_science_3/index.html#vectors",
    "href": "posts/r_data_science_3/index.html#vectors",
    "title": "R Basics II (Atomic Data Structures)",
    "section": "Vectors",
    "text": "Vectors\nA vector data form is an object holding multiple values of the same datatype, i.e. all numeric or all strings. We call objects with this property atomic.\nThere are multiple functions for constructing vectors in R including c(), seq(), :, and rep().\n\nc() Function\nThe simplest way to define a vector in R is using the c() function where you can specify each element of the vector within the parenthesis:\n\n# Numeric vector\nnum_vec &lt;- c(4,1,6,8,4,2,5)\nnum_vec\n\n[1] 4 1 6 8 4 2 5\n\n# Character string vector\nchar_vec &lt;- c(\"dog\", \"cat\", \"goose\", \"monkey\", \"elephant\")\nchar_vec\n\n[1] \"dog\"      \"cat\"      \"goose\"    \"monkey\"   \"elephant\"\n\n# Boolean vector\nbool_vec &lt;- c(\"TRUE\", \"FALSE\", \"FALSE\", \"FALSE\", \"TRUE\")\nbool_vec\n\n[1] \"TRUE\"  \"FALSE\" \"FALSE\" \"FALSE\" \"TRUE\" \n\n\n\n\nrep() Function\nThe rep() function is a simple way to construct vectors where a single value is repeated. The arguments for the function rep(x, times) where x specifies the scalar / vector you with to repeat and times specifies the number of times you want it repeated:\n\n# rep() function\nrep(x = 7, times = 14)\n\n [1] 7 7 7 7 7 7 7 7 7 7 7 7 7 7\n\n\n\n\nseq() Function\nThe seq() function is used specifically to construct numeric sequences. The syntax for seq(from, to, by, length.out) has arguments: (1) from specifying the starting values; (2) to specifying the final value; (3) by specifying the step size; and (4) length.out specifying the length of the resulting vector. Note that we cannot include arguments (3) and (4) at the same time!\n\n# seq() function with by\nseq(from = 1, to = 10, by = 2)\n\n[1] 1 3 5 7 9\n\n# seq() function with length.out\nseq(from = 1, to = 10, length.out = 9)\n\n[1]  1.000  2.125  3.250  4.375  5.500  6.625  7.750  8.875 10.000\n\n\nA quick alternative if we wish to make a vector of increasing integers is simply to use the : syntax:\n\n# integers from -3 to 4\n-3:4\n\n[1] -3 -2 -1  0  1  2  3  4\n\n\n\n\nCombining Methods\nAny of these functions can be nested within one another to produce more complicated vectors.\n\n# c() with seq() and rep()\nc(\n    rep(4, 5),\n    seq(0, 10, by = 1)\n)\n\n [1]  4  4  4  4  4  0  1  2  3  4  5  6  7  8  9 10\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\nUse any combinations of the above functions to reproduce the following vectors and save them to the corresponding objects.\n\ns\n\n [1] 1.00 1.25 1.50 1.75 2.00 1.00 9.00 1.00 9.00 1.00 9.00\n\nt\n\n [1] 1 2 3 4 4 3 2 1 0 0\n\n\n\n\n\n\nVector Properties\nOften (particularly for larger vectors) we wish to determine their properties such as their length (how many elements they contain) or their type (element datatype). To do so we can use the functions length() and typeof():\n\n# determine the length of the numeric vector from above\nlength(num_vec)\n\n[1] 7\n\n# confirm the data type of the character strring vector\ntypeof(char_vec)\n\n[1] \"character\"\n\n\n\n\nVector Indexing\nNow suppose we wish to retrieve only specific elements of a vector. We do so by indexing whereby we select which elements to return inside braces []. To return specific elements we simply note the numerical index of the element (i.e. 3 for the third element):\n\n# return the 3rd element of the boolean vector\nbool_vec[3]\n\n[1] \"FALSE\"\n\n# return the 3rd, 4th and 5th element of the numerical vector\nnum_vec[c(3,4,5)]\n\n[1] 6 8 4\n\n\nNote above that to return multiple elements we need to specify our index as a vector. To return every element besides specific elements we use negative indices:\n\n# return everything but the 3rd element of the boolean vector\nbool_vec[-3]\n\n[1] \"TRUE\"  \"FALSE\" \"FALSE\" \"TRUE\" \n\n# return everything but the 3rd, 4th and 5th element of the numerical vector\nnum_vec[-c(3,4,5)]\n\n[1] 4 1 2 5\n\n\n\n\nVector Filtering\nWe can also index vectors using logical statements, that is return elements of a vector that satisfy some logical condition, through a process known as filtering:\n\n# filter the numerical vector to return only numbers greater than or equal to 4\nnum_vec[num_vec &gt;= 4]\n\n[1] 4 6 8 4 5"
  },
  {
    "objectID": "posts/r_data_science_3/index.html#scalar",
    "href": "posts/r_data_science_3/index.html#scalar",
    "title": "R Basics II (Vectors, Matrices, Dataframes and Lists)",
    "section": "Scalar",
    "text": "Scalar\nA scalar data form is an object holding one value. For example:\n\nx &lt;- 16\ny &lt;- \"scalar\"\nz &lt;- FALSE\n\nWe often need to use different data structures that contain multiple values of different dimensions of different data types. R can handle data types including:\n\nVectors;\nMatrices;\nDataframes;\nLists.\n\nWe will go through the definition of each structure, how they are useful, and how we can construct and manipulate them in R."
  },
  {
    "objectID": "posts/r_data_science_3/index.html#scalars",
    "href": "posts/r_data_science_3/index.html#scalars",
    "title": "R Basics II (Atomic Data Structures)",
    "section": "Scalars",
    "text": "Scalars\nA scalar data form is an object holding one value. For example:\n\nx &lt;- 16\ny &lt;- \"scalar\"\nz &lt;- FALSE\n\nWe often need to use different data structures that contain multiple values of different dimensions of different data types. R can handle data types including: (1) Vectors; (2) Matrices; (3) Dataframes; and (4) Lists. In this note we will cover the atomic data types of vectors and matrices, specifically how we define them and how we perform computations with them."
  },
  {
    "objectID": "posts/r_data_science_3/index.html#vector-computations",
    "href": "posts/r_data_science_3/index.html#vector-computations",
    "title": "R Basics II (Vectors, Matrices, Dataframes and Lists)",
    "section": "Vector Computations",
    "text": "Vector Computations\nAtomic data structures are inflexible but their rigid structure allows for easy manipulation and computations. The mathematical background for vector arithmetic is studied in Linear Algebra. For the chapter discussing the basics of vector spaces and vector computations see here.\n\n# Define vectors\na &lt;- seq(1, 6, by = 1)\nb &lt;- rep(c(2,3),3)\n# Vector arithmetic\na + b\n\n[1] 3 5 5 7 7 9\n\n# Vector raised to power\na^2\n\n[1]  1  4  9 16 25 36\n\n# Scalar multiplication\n4*a\n\n[1]  4  8 12 16 20 24\n\n# Element-wise product\na * a\n\n[1]  1  4  9 16 25 36\n\n# Dot product\na %*% a\n\n     [,1]\n[1,]   91\n\n\nThere are also a collection of preloaded functions for performing computations and handling vectors such as:\n\nlength() - returns the number of elements in a vector;\ntypeof() - returns the type of vector (numeric, boolean, character);\n\n\n# Length of a vector\nlength(a)\n\n[1] 6\n\n# Vector type\ntypeof(b)\n\n[1] \"double\""
  },
  {
    "objectID": "posts/r_data_science_3/index.html#vector-functions",
    "href": "posts/r_data_science_3/index.html#vector-functions",
    "title": "R Basics II (Vectors, Matrices, Dataframes and Lists)",
    "section": "Vector Functions",
    "text": "Vector Functions\nThere are also a collection of preloaded functions for performing computations and handling vectors such as:\n\nlength() - returns the number of elements in a vector;\ntypeof() - returns the type of vector (numeric, boolean, character);"
  },
  {
    "objectID": "posts/r_data_science_3/index.html#indexing-and-filtering",
    "href": "posts/r_data_science_3/index.html#indexing-and-filtering",
    "title": "R Basics II (Vectors, Matrices, Dataframes and Lists)",
    "section": "Indexing and Filtering",
    "text": "Indexing and Filtering\nTo index a vector we use braces [] where we specify the numerical index of the element of the vector we are looking to gather:\n\n# Select the 4th element of vector a\na[4]\n\n[1] 4\n\n\nWe can specify the index of multiple values by specifying the vector of the index values:\n\n# Select the 2nd, 4th and 6th element of the vector b\nb[c(2,4,6)]\n\n[1] 3 3 3\n\n\nWe can also filter the vector using boolean vectors in the index:\n\n# Select all elements of a that are greater than 2\na[a &gt; 2]\n\n[1] 3 4 5 6"
  },
  {
    "objectID": "posts/r_data_science_3/index.html#matrices",
    "href": "posts/r_data_science_3/index.html#matrices",
    "title": "R Basics II (Atomic Data Structures)",
    "section": "Matrices",
    "text": "Matrices\nMatrices are essentially 2 dimensional vectors and so again the mathematics of matrix computations is given by Linear Algebra. For example, we define a matrix \\(A\\) with \\(4\\) columns and \\(3\\) rows by\n\\[\nA := \\begin{bmatrix}\na_{1,1} & a_{1,2} & a_{1,3} \\\\\na_{2,1} & a_{2,2} & a_{2,3} \\\\\na_{3,1} & a_{3,2} & a_{3,3} \\\\\na_{4,1} & a_{4,2} & a_{4,3}\n\\end{bmatrix},\n\\]\nwhere \\(a_{i,j}\\in\\mathbb{R}\\) for all \\(i,j\\). We can see that vectors are simply a specific kind of matrix, i.e. a matrix with only one column.\n\nContructing Matrices\nThere are three functions we use to construct matrices:\n\nmatrix();\nrbind();\ncbind().\n\n\nmatrix()\nThe simplest syntax for the matrix() function is:\n\n# matrix() syntax\nmatrix(data = NA, nrow = n, ncol = m, byrow = FALSE)\n\nwhere:\n\ndata - is a vector of the matrix elements;\nnrow - specifies the number of rows of the matrix;\nncol - specifies the number of columns of the matrix;\nbyrow - is a boolean specifying if the matrix should be built row-wise.\n\nFor an example, suppose we wish to construct a 4x4 matrix consisting of the integers from 1 to 16 constructed row-wise. Written mathematically, we wish to construct \\[\nA := \\begin{bmatrix}\n1 & 2 & 3 & 4 \\\\\n5 & 6 & 7 & 8 \\\\\n9 & 10 & 11 & 12 \\\\\n13 & 14 & 15 & 16\n\\end{bmatrix}.\n\\]\nTo construct this matrix in R we can write:\n\n# matrix() function\nA &lt;- matrix(1:16, nrow = 4, ncol = 4, byrow = TRUE)\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\n\n\n\n\nrbind() and cbind()\nSometimes we might have several vectors that we with to combine into a matrix. To combine vectors row-wise we use rbind() and to combine vectors column-wise we use cbind().\n\n# rbind() function\nrbind(1:4, 5:8, 9:12, 13:16)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\n\ncbind(1:4, 5:8, 9:12, 13:16)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\n\n\n\n\n\nMatrix Computations\nAtomic data structures are not flexible but this rigid structure allows them to be easily manipulated. The mathematical background for arithmetic with matrices is studied in Linear Algebra.\nWe can add to matrices together if they have the same number of columns and rows (just rows for vectors) in which case we say the matrices have the same dimension. In this case, the sum of two matrices is simply computed element-wise.\n\nB &lt;- matrix(\n    seq(from=2, length.out=16, by=2), \n    nrow = 4, ncol = 4, byrow = TRUE\n    )\nB\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    4    6    8\n[2,]   10   12   14   16\n[3,]   18   20   22   24\n[4,]   26   28   30   32\n\nA + B\n\n     [,1] [,2] [,3] [,4]\n[1,]    3    6    9   12\n[2,]   15   18   21   24\n[3,]   27   30   33   36\n[4,]   39   42   45   48\n\n\nSimilarly, scalar multiplication is computed element-wise.\n\n7 * A\n\n     [,1] [,2] [,3] [,4]\n[1,]    7   14   21   28\n[2,]   35   42   49   56\n[3,]   63   70   77   84\n[4,]   91   98  105  112\n\n\nWhen computing the cross-product of matrices \\(A\\times B\\) we require that the number of rows of \\(A\\) is equal to the number of columns of \\(B\\).\n\nA * B\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    8   18   32\n[2,]   50   72   98  128\n[3,]  162  200  242  288\n[4,]  338  392  450  512\n\nB * c(1,2,3)\n\nWarning in B * c(1, 2, 3): longer object length is not a multiple of shorter\nobject length\n\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    8   18    8\n[2,]   20   36   14   32\n[3,]   54   20   44   72\n[4,]   26   56   90   32\n\nB * c(1,2,3,4)\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    4    6    8\n[2,]   20   24   28   32\n[3,]   54   60   66   72\n[4,]  104  112  120  128\n\n\n\n\nMatrix Indexing\nWhen we wish to retrieve a specific element or elements of a data structure we need to perform indexing which in R. Considering the matrix \\(A\\) we defined earlier. If we wished to select the 5th element of the matrix we can use the brace [] syntax and write:\n\nA[5]\n\n[1] 2\n\n\nNow, supposing we wished to select from the 2nd to the 8th element of the matrix, we can use the same syntax but this time specifying a vector of the index values in the braces:\n\nA[2:8]\n\n[1]  5  9 13  2  6 10 14\n\n\nOften we might be more interested in selecting specific rows or columns of the matrix. To select a column we use the same syntax but this time with a comma A[i,j] where i specifies the row number of j specifies the column number. If we with to select the entire row we simply leave the value of j blank and vice versa:\n\n# 1st row\nA[1,]\n\n[1] 1 2 3 4\n\n# 4th column\nA[,4]\n\n[1]  4  8 12 16\n\n\nWe can select multiple rows / columns by using the same syntax as before and including a vector of the row / column index values you with to select:\n\n# 2nd and 3rd rows\nB[2:3, ]\n\n     [,1] [,2] [,3] [,4]\n[1,]   10   12   14   16\n[2,]   18   20   22   24\n\n# 2nd and 3rd rows + 1st and 4th columns\nA[2:3, c(1,4)]\n\n     [,1] [,2]\n[1,]    5    8\n[2,]    9   12\n\n\nWe can also chain index whereby we immediately index the output of our indexing:\n\nA[2:3, c(1,4)][2:3]\n\n[1] 9 8\n\n\n\n\nMatrix Filtering\nNow suppose we wish to only select elements of a matrix that specify a certain logical condition. We can again index but this time instead of specifying the index numbers we specify the condition we wish to be satisfied:\n\nA[A &gt; 10]\n\n[1] 13 14 11 15 12 16\n\n\nThis is particularly helpful when we wish to edit our original matrix. For example, if we wish to change \\(A\\) such that all elements \\(\\leq 10\\) are set to zero we could write:\n\nA_new &lt;- A\nA_new[A_new &lt; 10] &lt;- 0\nA_new\n\n     [,1] [,2] [,3] [,4]\n[1,]    0    0    0    0\n[2,]    0    0    0    0\n[3,]    0   10   11   12\n[4,]   13   14   15   16\n\n\n\n\nMatrix Functions\nThere are also a collection of preloaded functions for performing computations and handling vectors and matrices such as:\n\ndim() - returns the dimensions of a matrix (i.e. number of rows and columns);\ndet() - computes the determinant of a matrix;\nsolve() - computes the inverse of a matrix.\n\n\n# return the dimensions of A\ndim(A)\n\n[1] 4 4\n\n# compute the determinant of A\ndet(A)\n\n[1] 4.733165e-30\n\n# compute the inverse of A\n\nFor more information on matrix determinants and inverses please see my note on Linear Algebra Fundamentals\n\n  ← Previous Chapter \n  Next Chapter →"
  },
  {
    "objectID": "posts/r_data_science_3/index.html#vector-and-matrix-computations",
    "href": "posts/r_data_science_3/index.html#vector-and-matrix-computations",
    "title": "R Basics II (Vectors, Matrices, Dataframes and Lists)",
    "section": "Vector and Matrix Computations",
    "text": "Vector and Matrix Computations\nAtomic data structures are inflexible but their rigid structure allows for easy manipulation and computations. The mathematical background for vector arithmetic is studied in Linear Algebra. For the chapter discussing the basics of vector spaces and vector computations see here.\n\n# Define vectors\na &lt;- seq(1, 6, by = 1)\nb &lt;- rep(c(2,3),3)\n# Vector arithmetic\na + b\n\n[1] 3 5 5 7 7 9\n\n# Vector raised to power\na^2\n\n[1]  1  4  9 16 25 36\n\n# Scalar multiplication\n4*a\n\n[1]  4  8 12 16 20 24\n\n# Element-wise product\na * a\n\n[1]  1  4  9 16 25 36\n\n# Dot product\na %*% a\n\n     [,1]\n[1,]   91"
  },
  {
    "objectID": "posts/r_data_science_3/index.html#vector-and-matrix-functions",
    "href": "posts/r_data_science_3/index.html#vector-and-matrix-functions",
    "title": "R Basics II (Vectors, Matrices, Dataframes and Lists)",
    "section": "Vector and Matrix Functions",
    "text": "Vector and Matrix Functions\nThere are also a collection of preloaded functions for performing computations and handling vectors such as:\n\nlength() - returns the number of elements in a vector;\ntypeof() - returns the type of vector (numeric, boolean, character);\n\n\nMatrix Indexing and Filtering\nTo index a vector we use braces [] where we specify the numerical index of the element of the vector we are looking to gather:\n\n# Select the 4th element of vector a\nA[4]\n\n[1] 13\n\n\nWe can specify the index of multiple values by specifying the vector of the index values:\n\n# Select the 2nd, 4th and 6th element of the vector b\nB[c(2,4,6)]\n\n[1] 10 26 12\n\n\nWe can also filter the vector using boolean vectors in the index:\n\n# Select all elements of a that are greater than 2\nA[A &gt; 2]\n\n [1]  5  9 13  6 10 14  3  7 11 15  4  8 12 16"
  },
  {
    "objectID": "posts/r_data_science_3/index.html#matrix-computations",
    "href": "posts/r_data_science_3/index.html#matrix-computations",
    "title": "R Basics II (Vectors, Matrices, Dataframes and Lists)",
    "section": "Matrix Computations",
    "text": "Matrix Computations\nAtomic data structures are not flexible but this rigid structure allows them to be easily manipulated. The mathematical background for arithmetic with matrices is studied in Linear Algebra.\nWe can add to matrices together if they have the same number of columns and rows (just rows for vectors) in which case we say the matrices have the same dimension. In this case, the sum of two matrices is simply computed element-wise.\n\nB &lt;- matrix(\n    seq(from=2, length.out=16, by=2), \n    nrow = 4, ncol = 4, byrow = TRUE\n    )\nB\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    4    6    8\n[2,]   10   12   14   16\n[3,]   18   20   22   24\n[4,]   26   28   30   32\n\nA + B\n\n     [,1] [,2] [,3] [,4]\n[1,]    3    6    9   12\n[2,]   15   18   21   24\n[3,]   27   30   33   36\n[4,]   39   42   45   48\n\n\nSimilarly, scalar multiplication is computed element-wise.\n\n7 * A\n\n     [,1] [,2] [,3] [,4]\n[1,]    7   14   21   28\n[2,]   35   42   49   56\n[3,]   63   70   77   84\n[4,]   91   98  105  112\n\n\nWhen computing the cross-product of matrices \\(A\\times B\\) we require that the number of rows of \\(A\\) is equal to the number of columns of \\(B\\).\n\nA * B\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    8   18   32\n[2,]   50   72   98  128\n[3,]  162  200  242  288\n[4,]  338  392  450  512\n\nB * c(1,2,3)\n\nWarning in B * c(1, 2, 3): longer object length is not a multiple of shorter\nobject length\n\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    8   18    8\n[2,]   20   36   14   32\n[3,]   54   20   44   72\n[4,]   26   56   90   32\n\nB * c(1,2,3,4)\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    4    6    8\n[2,]   20   24   28   32\n[3,]   54   60   66   72\n[4,]  104  112  120  128"
  },
  {
    "objectID": "posts/r_data_science_3/index.html#matrix-indexing-and-filtering",
    "href": "posts/r_data_science_3/index.html#matrix-indexing-and-filtering",
    "title": "R Basics II (Vectors, Matrices, Dataframes and Lists)",
    "section": "Matrix Indexing and Filtering",
    "text": "Matrix Indexing and Filtering\n\nIndexing\nWhen we wish to retrieve a specific element or elements of a data structure we need to perform indexing which in R. Considering the matrix \\(A\\) we defined earlier. If we wished to select the 5th element of the matrix we can use the brace [] syntax and write:\n\nA[5]\n\n[1] 2\n\n\nNow, supposing we wished to select from the 2nd to the 8th element of the matrix, we can use the same syntax but this time specifying a vector of the index values in the braces:\n\nA[2:8]\n\n[1]  5  9 13  2  6 10 14\n\n\nOften we might be more interested in selecting specific rows or columns of the matrix. To select a column we use the same syntax but this time with a comma A[i,j] where i specifies the row number of j specifies the column number. If we with to select the entire row we simply leave the value of j blank and vice versa:\n\n# 1st row\nA[1,]\n\n[1] 1 2 3 4\n\n# 4th column\nA[,4]\n\n[1]  4  8 12 16\n\n\nWe can select multiple rows / columns by using the same syntax as before and including a vector of the row / column index values you with to select:\n\n# 2nd and 3rd rows\nB[2:3, ]\n\n     [,1] [,2] [,3] [,4]\n[1,]   10   12   14   16\n[2,]   18   20   22   24\n\n# 2nd and 3rd rows + 1st and 4th columns\nA[2:3, c(1,4)]\n\n     [,1] [,2]\n[1,]    5    8\n[2,]    9   12\n\n\nWe can also chain index whereby we immediately index the output of our indexing:\n\nA[2:3, c(1,4)][2:3]\n\n[1] 9 8\n\n\n\n\nFiltering\nNow suppose we wish to only select elements of a matrix that specify a certain logical condition. We can again index but this time instead of specifying the index numbers we specify the condition we wish to be satisfied:\n\nA[A &gt; 10]\n\n[1] 13 14 11 15 12 16\n\n\nThis is particularly helpful when we wish to edit our original matrix. For example, if we wish to change \\(A\\) such that all elements \\(\\leq 10\\) are set to zero we could write:\n\nA[A &lt; 10] &lt;- 0\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    0    0    0    0\n[2,]    0    0    0    0\n[3,]    0   10   11   12\n[4,]   13   14   15   16"
  },
  {
    "objectID": "posts/r_data_science_3/index.html#matrix-functions",
    "href": "posts/r_data_science_3/index.html#matrix-functions",
    "title": "R Basics II (Vectors, Matrices, Dataframes and Lists)",
    "section": "Matrix Functions",
    "text": "Matrix Functions\nThere are also a collection of preloaded functions for performing computations and handling vectors and matrices such as:\n\nlength() - returns the number of elements in a vector;\ntypeof() - returns the type of vector (numeric, boolean, character);\ndim() - returns the dimensions of a matrix;\ndet() - computes the determinant of a matrix;\nsolve() - computes the inverse of a matrix;\n\n\n  ← Previous Chapter \n  Next Chapter →"
  },
  {
    "objectID": "posts/r_data_science_4/index.html",
    "href": "posts/r_data_science_4/index.html",
    "title": "R Basics III (Dataframes and Lists)",
    "section": "",
    "text": "This post contains notes for Chapter 4 of my course series Data Science with R covering dataframes and lists.\n\n\n\n Back to top"
  },
  {
    "objectID": "posts/sdsim1/index.html",
    "href": "posts/sdsim1/index.html",
    "title": "Simulating SDEs for Option Pricing",
    "section": "",
    "text": "This note is based on material covered by Prof. Michael Ludkovski in his class on Computational Statistics held in Spring 2025 at UC Santa Barbara, which is sourced largely from the textbook An introduction to the numerical simulation of stochastic differential equations by Desmond J. Higham, Peter E. Kloeden."
  },
  {
    "objectID": "posts/sdsim1/index.html#motivation",
    "href": "posts/sdsim1/index.html#motivation",
    "title": "Simulating SDEs for Option Pricing",
    "section": "Motivation",
    "text": "Motivation\nOften SDEs (much like PDEs) are not solvable analytically leading us to turn to numerical methods to find solutions. This raises the question of how can we efficiently simulate these processes and how can we measure the accuracy of our approximations?\nFor a practical example we look at pricing 3 options:\n\nA European call option - where the option pays when the terminal value of the option is above some prespecified strike price;\nAn Asian put option - where the option pays the difference the average value over the underlying asset; and\nA corridor option - that pays a predetermined amount if the underlying asset remains within some price corridor (e.g. over 10 and under 20).\n\nWe will take our underlying asset to be a stock whose price process \\((S_t)\\) has dynamics given by the Black-Scholes-Merton model \\[\ndS_t = \\mu S_t dt + \\sigma S_t dW_t\n\\]\nwhere \\(\\mu,\\sigma\\in\\mathbb{R}\\) and \\((W_t)\\) is a standard Wiener process under the risk-free measure \\(\\mathbb{Q}\\). This is known as the Black-Scholes-Merton model and the details of this model along with the derivation of the Black-Scholes equation can be found in our note here. Using the substitution \\(Y_t = \\log(X_t)\\) and applying Itô’s formula we obtain the solution \\[\nS_{t}=S_{0}e^{(\\mu-\\frac{\\sigma^2}{2})t+\\sigma W_{t}},\\tag{2}\n\\]\nand so under the BS model we are able to obtain true probabilistic simulations of the stock price at any time \\(t\\) given any initial time \\(s&lt;t\\) since the solution is deterministic up to the Wiener process increment which is normally distributed \\[\nW_t - W_s \\sim \\mathcal{N}(0, t-s).\n\\]\nConsider a stock with drift \\(\\mu = 0.04\\), diffusion \\(\\sigma=0.25\\), initial price \\(\\$120\\) and expiration \\(T=10\\). We simulate the price of the stock at time \\(T\\) using \\((2)\\) as follows:\n\n## Define price function\nbsm_true &lt;- function(mu, sigma, s0, t0, t1) {\n    s1 &lt;- s0 * exp((mu - sigma^2/2)*(t1-t0) + sigma*sqrt(t1-t0)*rnorm(1))\n    return(s1)\n}\n## Generate 100000 realizations\nST &lt;- replicate(\n    100000, \n    bsm_true(\n        mu = 0.05,\n        sigma = 0.2,\n        s0 = 49,\n        t0 = 0,\n        t1 = 20/52\n    )\n)\n\nWe can look at the empirical distribution of our generated terminal price sample using a histogram:\n\n## Produce histogram\ndata.frame(\n    Number = 1:length(ST),\n    Terminal_Price = ST\n ) |&gt;\n    ggplot(aes(x = ST)) +\n    geom_histogram(binwidth = 1) +\n    theme_light()\n\n\n\n\nEmpirical distribution of true simulated stock prices given by the BS model.\n\n\n\n\nA European call option is a financial derivative giving an individual has the option but not the obligation to purchase stock at some prespecified future expiration date at a preset strike price \\(K\\). The payoff of the option is given by \\[\ng(S_T) = (S_T - K)_+ = \\max(S_T - K, 0),\n\\]\nwhere the option makes money for the holder only if the stock price at expiration is higher than the strike price \\(K\\). The price of the option is given by the expected value of this random variable \\(g(S_T)\\) \\[\n\\mathbb{E}[g(S_T)]=\\mathbb{E}[(S_T - K)_+].\n\\]\nSay in our case we wanted to price an option with strike price \\(K=50\\). Using our previous simulation we can simply compute:\n\n## Euro Call Option Price\nexp(-0.05*(20/52))*mean( pmax(ST - 50, 0))\n\n[1] 2.400116"
  },
  {
    "objectID": "posts/sdsim1/index.html#eulermaruyama-method",
    "href": "posts/sdsim1/index.html#eulermaruyama-method",
    "title": "Simulating SDEs for Option Pricing",
    "section": "Euler–Maruyama Method",
    "text": "Euler–Maruyama Method"
  },
  {
    "objectID": "posts/linear_algebra_fundamentals/index.html",
    "href": "posts/linear_algebra_fundamentals/index.html",
    "title": "Linear Algebra Fundamentals",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "posts/rds1-installation/index.html",
    "href": "posts/rds1-installation/index.html",
    "title": "Installing and using R and RStudio",
    "section": "",
    "text": "This post contains notes for Chapter 1 of my course series Data Science with R covering how to install both the language R and the IDE RStudio, and the basics of using the IDE for data analysis."
  },
  {
    "objectID": "posts/rds1-installation/index.html#background-information",
    "href": "posts/rds1-installation/index.html#background-information",
    "title": "Installing and using R and RStudio",
    "section": "Background Information",
    "text": "Background Information\nR is a programming language (like python or C++) whilst RStudio is a software that facilitates writing R scripts known as an Intergrated Development Enviroment (IDE). In this course we will learn how to write in the R language using the IDE RStudio.\nR can be used to perform and automate computations, generate plots, simulate from random variables and perform statistical analysis. RStudio is primarily an R focussed IDE but it also has the capability of producing technical documents in a variety of formats using Quarto markdown. You can find some fabulous online documentation about the capabilities of Quarto markdown documents here."
  },
  {
    "objectID": "posts/rds1-installation/index.html#installation",
    "href": "posts/rds1-installation/index.html#installation",
    "title": "Installing and using R and RStudio",
    "section": "Installation",
    "text": "Installation\nR is not natively loaded on your computer and so to begin with we need to install both the language and the IDE onto our computers, the downloads for which can be found on the posit website. You will need to check that you download versions of both R and RStudio that match your operating system.\n\n\n\nPosit website R and RStudio download screen.\n\n\nR will be loaded onto your local drive and can mostly be forgotten about. RStudio will be downloaded into your applications folder and once the download is complete you can open the application to get started."
  },
  {
    "objectID": "posts/rds1-installation/index.html#rstudio-layout",
    "href": "posts/rds1-installation/index.html#rstudio-layout",
    "title": "Installing and using R and RStudio",
    "section": "RStudio Layout",
    "text": "RStudio Layout\nWhen you first open RStudio the application will be split into several sections called panes, each with a selection of tabs.\n\n\n\nRStudio Layout.\n\n\nWe will first go through the most important tabs and what they are used for:\n\nLeft Pane:\n\nConsole Tab - Where R code can be read and executed by your computer.\nTerminal Tab - Providing command line access to the computer’s operating system (this is rarely used by beginners).\n\nUpper Right Pane:\n\nEnvironment Tab - A breakdown of items saved in the working memory.\n\nLower Right Pane:\n\nFiles Tab - A view of your system files.\nPlots Tab - A space displaying any plot you generate.\nPackages Tab - A manager to load functions defined by other users known as packages.\nHelp Tab - A space to search for and view code documentation."
  },
  {
    "objectID": "posts/rds1-installation/index.html#system-vs-working-memory",
    "href": "posts/rds1-installation/index.html#system-vs-working-memory",
    "title": "Installing and using R and RStudio",
    "section": "System vs Working Memory",
    "text": "System vs Working Memory\nAnytime you define something in R (discussed in a later chapter) it will be saved to RStudios working (short-term) memory, shown in the environment tab. The available memory is limited and it is important to remember that anything stored here will be deleted once you close RStudio.\nFor long term storage you will need to save objects to your system memory (your computers filing system), shown in the files tab. You will then be able to load anything you have saved for later use. In this course we will typically only use our system memory for saving our R scripts (text documents in which we write our code), accessing data files or for generating and saving .pdf documents.\nRStudios working environment is the file on your system that RStudio is currently looking within (i.e. what it can pull files from and save files too). The default working directory location is the file that is shown within the files tab. You can set a new working directory at anytime by either:\n\nNavigating to the desired folder in the files tab, clicking on the more settings cog and selecting Set as Working Directory.\nTyping setwd(\"desired_file_path\") into the R console.\n\nIn the image below you can see that I have created a folder titled Data Science with R in my system Documents folder and set this as my working directory.\n\n\n\nSet working directory,\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\nLets prepare to create our first R script. First navigate to your desired course folder (or create on) and set it as your working directory."
  },
  {
    "objectID": "posts/rds1-installation/index.html#creating-r-scripts",
    "href": "posts/rds1-installation/index.html#creating-r-scripts",
    "title": "Installing and using R and RStudio",
    "section": "Creating R Scripts",
    "text": "Creating R Scripts\nNow we are ready to create our first R script by using any of the following methods:\n\nNavigate to file &gt; New File &gt; R Script;\nUse the shortcut shift + cmd + N on mac;\nClick the small + button at the top left of the application window and select R Script.\n\n\n\n\nCreating a new R Script.\n\n\nAfter this a new pane will appear in the top left position showing an unititled document with the suffix .R. We can save this file using either:\n\nThe shortcut CMD + S;\nClicking File &gt; Save,\n\nand the document should then appear in our working directory, therefore in our system storage.\n\n\n\nSaved script appearing in our working directory.\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nCreate and save your first R script (choose whatever name you like) to your working directory."
  },
  {
    "objectID": "posts/rds1-installation/index.html#packages",
    "href": "posts/rds1-installation/index.html#packages",
    "title": "Installing and using R and RStudio",
    "section": "Packages",
    "text": "Packages\nR comes preloaded with a variety of functions, called base functions however there are many tasks for which they are insufficient (advanced plotting, statistical modelling etc.). CRAN Packages are collections of functions written in R by other users that are available for download. A comprehensive list of the available packages are detailed on the CRAN website.\nThroughout this course we will use a variety of packages (such as tidyverse) and so it is important we know how to load and use the in-built package management in RStudio. navigating to the packages tab we will see a list of pre-installed packages with empty check marks next to them. These packages are installed (downloaded from the internet) but not loaded (not available for use in our R session).\nTo install a package (e.g. tidyverse) we can use the install.packages() function where the input to the function is the name of the package enclosed in quotation marks:\n\ninstall.packages('tidyverse')\n\nYou will see the package appear with no check mark in the packages manager. Note that once a package is installed it will not need to be installed in future unless you reinstall RStudio (which is why we often omit this code in scripts).\nNext, to load a package we can use the library()function where this time the input is the name of the package with no quotation marks:\n\nlibrary(tidyverse)\n\nYour console output will often provide relevant information about the version of the package and its compatibility with your downloaded version of R and other loaded packages. Running this function will check the box next to tidyverse in the package tab.\nI recommend including all your package loading functions at the top of your script so you can quickly check what packages you have loaded in your session.\n\n\n\nPackage tab with loaded tidyverse package.\n\n\nOccasionally you might have loaded multiple packages which have conflicting package names. In this case, you may want to unload a package which you can do using the detach() function. The syntax for the input is a little more complicated:\n\ndetach(\"package:tidyverse\", unload = TRUE)\n\n\n\n\n\n\n\nExercise 3\n\n\n\nBy writing code in your console install the packages: (1) tidyverse; (2) astsa and (3) zoo, using the install.packages() function. Now in your script use the library() function to load all three packages."
  },
  {
    "objectID": "posts/rds1-installation/index.html#help-function",
    "href": "posts/rds1-installation/index.html#help-function",
    "title": "Installing and using R and RStudio",
    "section": "Help Function",
    "text": "Help Function\nOne of my most used functions in R is ? which quickly loads to documentation for the specified function in the Help tab. An example of using this function to return information about the base mean() function is:\n\n?mean()\n\nIf you run this code you will see the documentation for the mean() function displayed in the Help tab.\n\n\n\nHelp function output for mean() function.\n\n\n\n\n\n\n\n\nExercise 4\n\n\n\nIn the tidyverse function you have just loaded there is a function ggplot(). Use the help ? syntax to load and read the documentation."
  },
  {
    "objectID": "posts/rds1-installation/index.html#review",
    "href": "posts/rds1-installation/index.html#review",
    "title": "Installing and using R and RStudio",
    "section": "Review",
    "text": "Review\nAt the end of this short lesson we should now be able to:\n\nDownload and install both R and RStudio.\nSet our working directory.\nCreate new R scripts and save them.\nInstall and load packages.\nUse the help function to search for documentation.\n\n\n  ← Course Homepage \n  Next Chapter →"
  },
  {
    "objectID": "courses/linear_algebra/index.html",
    "href": "courses/linear_algebra/index.html",
    "title": "Linear Algebra",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "posts/rds4-basics3-dataframes/index.html",
    "href": "posts/rds4-basics3-dataframes/index.html",
    "title": "R Basics III - Dataframes and Lists",
    "section": "",
    "text": "This post contains notes for Chapter 4 of my course series Data Science with R covering dataframes and lists. Specifically we will look at R’s base functionality for dataframes and lists including how to construct and manipulate these objects. We note that although it is preferable to manipulate dataframes using the tidyverse package (something we cover in a future lesson) this note focusses first on detailing the base functionality."
  },
  {
    "objectID": "posts/rds3-basics2-atomicdata/index.html",
    "href": "posts/rds3-basics2-atomicdata/index.html",
    "title": "R Basics II - Atomic Data Structures",
    "section": "",
    "text": "This post contains notes for Chapter 3 of my course series Data Science with R covering atomic data structures. Specifically, we discuss scalars, vectors and matrices, how to construct them, manipulate them, and perform computations with them. For efficiency I avoid discussion of the underlying mathematics of vector and matrix computations and direct any interested readers towards my course and relevant notes on Linear Algebra."
  },
  {
    "objectID": "posts/rds3-basics2-atomicdata/index.html#scalars",
    "href": "posts/rds3-basics2-atomicdata/index.html#scalars",
    "title": "R Basics II - Atomic Data Structures",
    "section": "Scalars",
    "text": "Scalars\nA scalar data form is an object holding one value. For example:\n\nx &lt;- 16\ny &lt;- \"scalar\"\nz &lt;- FALSE\n\nWe often need to use different data structures that contain multiple values of different dimensions of different data types. R can handle data types including: (1) Vectors; (2) Matrices; (3) Dataframes; and (4) Lists. In this note we will cover the atomic data types of vectors and matrices, specifically how we define them and how we perform computations with them."
  },
  {
    "objectID": "posts/rds3-basics2-atomicdata/index.html#vectors",
    "href": "posts/rds3-basics2-atomicdata/index.html#vectors",
    "title": "R Basics II - Atomic Data Structures",
    "section": "Vectors",
    "text": "Vectors\nA vector data form is an object holding multiple values of the same datatype, i.e. all numeric or all strings. We call objects with this property atomic.\nThere are multiple functions for constructing vectors in R including c(), seq(), :, and rep().\n\nc() Function\nThe simplest way to define a vector in R is using the c() function where you can specify each element of the vector within the parenthesis:\n\n# Numeric vector\nnum_vec &lt;- c(4,1,6,8,4,2,5)\nnum_vec\n\n[1] 4 1 6 8 4 2 5\n\n# Character string vector\nchar_vec &lt;- c(\"dog\", \"cat\", \"goose\", \"monkey\", \"elephant\")\nchar_vec\n\n[1] \"dog\"      \"cat\"      \"goose\"    \"monkey\"   \"elephant\"\n\n# Boolean vector\nbool_vec &lt;- c(\"TRUE\", \"FALSE\", \"FALSE\", \"FALSE\", \"TRUE\")\nbool_vec\n\n[1] \"TRUE\"  \"FALSE\" \"FALSE\" \"FALSE\" \"TRUE\" \n\n\n\n\nrep() Function\nThe rep() function is a simple way to construct vectors where a single value is repeated. The arguments for the function rep(x, times) where x specifies the scalar / vector you with to repeat and times specifies the number of times you want it repeated:\n\n# rep() function\nrep(x = 7, times = 14)\n\n [1] 7 7 7 7 7 7 7 7 7 7 7 7 7 7\n\n\n\n\nseq() Function\nThe seq() function is used specifically to construct numeric sequences. The syntax for seq(from, to, by, length.out) has arguments: (1) from specifying the starting values; (2) to specifying the final value; (3) by specifying the step size; and (4) length.out specifying the length of the resulting vector. Note that we cannot include arguments (3) and (4) at the same time!\n\n# seq() function with by\nseq(from = 1, to = 10, by = 2)\n\n[1] 1 3 5 7 9\n\n# seq() function with length.out\nseq(from = 1, to = 10, length.out = 9)\n\n[1]  1.000  2.125  3.250  4.375  5.500  6.625  7.750  8.875 10.000\n\n\nA quick alternative if we wish to make a vector of increasing integers is simply to use the : syntax:\n\n# integers from -3 to 4\n-3:4\n\n[1] -3 -2 -1  0  1  2  3  4\n\n\n\n\nCombining Methods\nAny of these functions can be nested within one another to produce more complicated vectors.\n\n# c() with seq() and rep()\nc(\n    rep(4, 5),\n    seq(0, 10, by = 1)\n)\n\n [1]  4  4  4  4  4  0  1  2  3  4  5  6  7  8  9 10\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\nUse any combinations of the above functions to reproduce the following vectors and save them to the corresponding objects.\n\ns\n\n [1] 1.00 1.25 1.50 1.75 2.00 1.00 9.00 1.00 9.00 1.00 9.00\n\nt\n\n [1] 1 2 3 4 4 3 2 1 0 0\n\n\n\n\n\n\nImportant Vector Functions\nWhen working with vectors we will often use several key base functions to ascertain important properties and manipulate vector objects. The first of these key functions is length() which returns the number of elements of a vector:\n\nlength(num_vec)\n\n[1] 7\n\n\nNext, it is often useful to know what datatype the vector contains, something that we can determine with the typeof() function:\n\n# confirm the data type of the character strring vector\ntypeof(char_vec)\n\n[1] \"character\"\n\n\nFinally, we often wish to sort vectors into some kind of order (e.g. alphabetical, decreasing). To accomplish this we can use the sort() function:\n\n# sort numerical vector in increasing order\nsort(num_vec, decreasing = FALSE)\n\n[1] 1 2 4 4 5 6 8\n\n\nNote that here we have specified decreasing = FALSE in the function. This is what is known as an argument and they are what allow to control more sophisticated functions. With any function we can see details of what arguments we can specify by using the help() or ? functions.\n\n\nVector Indexing\nNow suppose we wish to retrieve only specific elements of a vector. We do so by indexing whereby we select which elements to return inside braces []. To return specific elements we simply note the numerical index of the element (i.e. 3 for the third element):\n\n# return the 3rd element of the boolean vector\nbool_vec[3]\n\n[1] \"FALSE\"\n\n# return the 3rd, 4th and 5th element of the numerical vector\nnum_vec[c(3,4,5)]\n\n[1] 6 8 4\n\n\nNote above that to return multiple elements we need to specify our index as a vector. To return every element besides specific elements we use negative indices:\n\n# return everything but the 3rd element of the boolean vector\nbool_vec[-3]\n\n[1] \"TRUE\"  \"FALSE\" \"FALSE\" \"TRUE\" \n\n# return everything but the 3rd, 4th and 5th element of the numerical vector\nnum_vec[-c(3,4,5)]\n\n[1] 4 1 2 5\n\n\n\n\nVector Filtering\nWe can also index vectors using logical statements, that is return elements of a vector that satisfy some logical condition, through a process known as filtering:\n\n# filter the numerical vector to return only numbers greater than or equal to 4\nnum_vec[num_vec &gt;= 4]\n\n[1] 4 6 8 4 5\n\n\n\n\nVector Computations\nOne of the strengths of R as a programming language is its efficiency with performing vector computations. There are a variety of vector computations we can perform, starting with muliplication by a scalar which is applied element-wise:\n\n# vector times a scalar\n2 * c(1,2,3,4)\n\n[1] 2 4 6 8\n\n\nWe can also add a scalar and a vector which is also applied element-wise:\n\n2 + c(1,2,3,4)\n\n[1] 3 4 5 6\n\n\nIf we wish to add or multiply two vectors we must ensure they are of the same length:\n\n# add two vectors\nc(1,2,3) + c(10,12,14)\n\n[1] 11 14 17\n\n# multiply two vectors\nc(1,2,3) * c(10,12,14)\n\n[1] 10 24 42\n\n\n\n\nRecycling\nYou might ask yourself what happens if we add together two vectors of different lengths?\n\nc(1,2) + c(10,20,30,40)\n\n[1] 11 22 31 42\n\n\nFrom this example you might have discerned that R did not return an error message but instead recycled values of the smaller vector (looping from start to finish) to perform the computation.\n\n\nCoercion\nVector coercion is when R changes the data type in a vector when it is presented with a situation when you are trying to combine different data types. The default order of priority taken by R is:\n\nCharacter Strings;\nNumeric; and\nBoolean.\n\n\n# Coercion from boolean to numeric\nc(TRUE, FALSE, 1,2,3,1)\n\n[1] 1 0 1 2 3 1\n\n# Coercion from boolen and numeric to character strings\nc(\"Dog\", TRUE, TRUE, 5, 10)\n\n[1] \"Dog\"  \"TRUE\" \"TRUE\" \"5\"    \"10\""
  },
  {
    "objectID": "posts/rds3-basics2-atomicdata/index.html#matrices",
    "href": "posts/rds3-basics2-atomicdata/index.html#matrices",
    "title": "R Basics II - Atomic Data Structures",
    "section": "Matrices",
    "text": "Matrices\nMatrices are essentially 2 dimensional vectors and so again the mathematics of matrix computations is given by Linear Algebra. For example, we define a matrix \\(A\\) with \\(4\\) columns and \\(3\\) rows by\n\\[\nA := \\begin{bmatrix}\na_{1,1} & a_{1,2} & a_{1,3} \\\\\na_{2,1} & a_{2,2} & a_{2,3} \\\\\na_{3,1} & a_{3,2} & a_{3,3} \\\\\na_{4,1} & a_{4,2} & a_{4,3}\n\\end{bmatrix},\n\\]\nwhere \\(a_{i,j}\\in\\mathbb{R}\\) for all \\(i,j\\). We can see that vectors are simply a specific kind of matrix, i.e. a matrix with only one column.\n\nConstructing Matrices\nThere are three functions we use to construct matrices:\n\nmatrix();\nrbind();\ncbind().\n\n\nmatrix()\nThe simplest syntax for the matrix() function is:\n\n# matrix() syntax\nmatrix(data = NA, nrow = n, ncol = m, byrow = FALSE)\n\nwhere:\n\ndata - is a vector of the matrix elements;\nnrow - specifies the number of rows of the matrix;\nncol - specifies the number of columns of the matrix;\nbyrow - is a boolean specifying if the matrix should be built row-wise.\n\nFor an example, suppose we wish to construct a 4x4 matrix consisting of the integers from 1 to 16 constructed row-wise. Written mathematically, we wish to construct \\[\nA := \\begin{bmatrix}\n1 & 2 & 3 & 4 \\\\\n5 & 6 & 7 & 8 \\\\\n9 & 10 & 11 & 12 \\\\\n13 & 14 & 15 & 16\n\\end{bmatrix}.\n\\]\nTo construct this matrix in R we can write:\n\n# matrix() function\nA &lt;- matrix(1:16, nrow = 4, ncol = 4, byrow = TRUE)\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\n\n\n\n\nrbind() and cbind()\nSometimes we might have several vectors that we with to combine into a matrix. To combine vectors row-wise we use rbind() and to combine vectors column-wise we use cbind().\n\n# rbind() function\nrbind(1:4, 5:8, 9:12, 13:16)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\n\ncbind(1:4, 5:8, 9:12, 13:16)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\n\n\n\n\n\nMatrix Computations\nAtomic data structures are not flexible but this rigid structure allows them to be easily manipulated. The mathematical background for arithmetic with matrices is studied in Linear Algebra.\nWe can add to matrices together if they have the same number of columns and rows (just rows for vectors) in which case we say the matrices have the same dimension. In this case, the sum of two matrices is simply computed element-wise.\n\nB &lt;- matrix(\n    seq(from=2, length.out=16, by=2), \n    nrow = 4, ncol = 4, byrow = TRUE\n    )\nB\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    4    6    8\n[2,]   10   12   14   16\n[3,]   18   20   22   24\n[4,]   26   28   30   32\n\nA + B\n\n     [,1] [,2] [,3] [,4]\n[1,]    3    6    9   12\n[2,]   15   18   21   24\n[3,]   27   30   33   36\n[4,]   39   42   45   48\n\n\nSimilarly, scalar multiplication is computed element-wise.\n\n7 * A\n\n     [,1] [,2] [,3] [,4]\n[1,]    7   14   21   28\n[2,]   35   42   49   56\n[3,]   63   70   77   84\n[4,]   91   98  105  112\n\n\nWhen computing the cross-product of matrices \\(A\\times B\\) we require that the number of rows of \\(A\\) is equal to the number of columns of \\(B\\).\n\nA * B\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    8   18   32\n[2,]   50   72   98  128\n[3,]  162  200  242  288\n[4,]  338  392  450  512\n\nB * c(1,2,3)\n\nWarning in B * c(1, 2, 3): longer object length is not a multiple of shorter\nobject length\n\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    8   18    8\n[2,]   20   36   14   32\n[3,]   54   20   44   72\n[4,]   26   56   90   32\n\nB * c(1,2,3,4)\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    4    6    8\n[2,]   20   24   28   32\n[3,]   54   60   66   72\n[4,]  104  112  120  128\n\n\n\n\nMatrix Indexing\nWhen we wish to retrieve a specific element or elements of a data structure we need to perform indexing which in R. Considering the matrix \\(A\\) we defined earlier. If we wished to select the 5th element of the matrix we can use the brace [] syntax and write:\n\nA[5]\n\n[1] 2\n\n\nNow, supposing we wished to select from the 2nd to the 8th element of the matrix, we can use the same syntax but this time specifying a vector of the index values in the braces:\n\nA[2:8]\n\n[1]  5  9 13  2  6 10 14\n\n\nOften we might be more interested in selecting specific rows or columns of the matrix. To select a column we use the same syntax but this time with a comma A[i,j] where i specifies the row number of j specifies the column number. If we with to select the entire row we simply leave the value of j blank and vice versa:\n\n# 1st row\nA[1,]\n\n[1] 1 2 3 4\n\n# 4th column\nA[,4]\n\n[1]  4  8 12 16\n\n\nWe can select multiple rows / columns by using the same syntax as before and including a vector of the row / column index values you with to select:\n\n# 2nd and 3rd rows\nB[2:3, ]\n\n     [,1] [,2] [,3] [,4]\n[1,]   10   12   14   16\n[2,]   18   20   22   24\n\n# 2nd and 3rd rows + 1st and 4th columns\nA[2:3, c(1,4)]\n\n     [,1] [,2]\n[1,]    5    8\n[2,]    9   12\n\n\nWe can also chain index whereby we immediately index the output of our indexing:\n\nA[2:3, c(1,4)][2:3]\n\n[1] 9 8\n\n\n\n\nMatrix Filtering\nNow suppose we wish to only select elements of a matrix that specify a certain logical condition. We can again index but this time instead of specifying the index numbers we specify the condition we wish to be satisfied:\n\nA[A &gt; 10]\n\n[1] 13 14 11 15 12 16\n\n\nThis is particularly helpful when we wish to edit our original matrix. For example, if we wish to change \\(A\\) such that all elements \\(\\leq 10\\) are set to zero we could write:\n\nA_new &lt;- A\nA_new[A_new &lt; 10] &lt;- 0\nA_new\n\n     [,1] [,2] [,3] [,4]\n[1,]    0    0    0    0\n[2,]    0    0    0    0\n[3,]    0   10   11   12\n[4,]   13   14   15   16\n\n\n\n\nMatrix Functions\nThere are also a collection of preloaded functions for performing computations and handling vectors and matrices such as:\n\ndim() - returns the dimensions of a matrix (i.e. number of rows and columns);\ndet() - computes the determinant of a matrix;\nsolve() - computes the inverse of a matrix.\n\n\n# return the dimensions of A\ndim(A)\n\n[1] 4 4\n\n# compute the determinant of A\ndet(A)\n\n[1] 4.733165e-30\n\n\nFor more information on matrix determinants and inverses please see my course notes on Linear Algebra\n\n  ← Previous Chapter \n  Next Chapter →"
  },
  {
    "objectID": "posts/rds2-basics1-operators/index.html",
    "href": "posts/rds2-basics1-operators/index.html",
    "title": "R Basics I - Operators, Logic & Data Types",
    "section": "",
    "text": "This post contains notes for Chapter 2 of my course series Data Science with R covering the basic use of R as a calculator including computations, logic, data types and the assignment operator."
  },
  {
    "objectID": "posts/rds2-basics1-operators/index.html#calculations",
    "href": "posts/rds2-basics1-operators/index.html#calculations",
    "title": "R Basics I - Operators, Logic & Data Types",
    "section": "Calculations",
    "text": "Calculations\nWe can perform a wide variety of mathematical calculations using R including:\n\nMultiplication, addition, division, subtraction;\nRaising to powers and square rooting;\nTrigonometric functions;\nExponential and logarithmic functions.\n\nThe syntax to apply these operations is often very intuitive but slightly different to the mathematical notation. Note that all computations written in R follow the BIDMAS (Brackets, Indices, Division, Multiplication, Addition, Subtraction) order of operations rule and so take care to ensure clarity with parentheses if necessary.\n\nAddition, Subtraction, Multiplication and Division\n\n# Addition\n21 + 47 \n\n[1] 68\n\n# Subtraction\n456 - 564 \n\n[1] -108\n\n# Multiplication\n7*23      \n\n[1] 161\n\n# Division\n45/23     \n\n[1] 1.956522\n\n\n\n\nPowers and Square Roots\nTo raise numbers to powers we can use the ^ symbol. Note that if we wish to raise numbers to fractional powers we must ensure to enclose our fraction in parentheses (). Further, there is a specifically defined function for computing the square root of a number sqrt().\n\n\n\n\n\n\nImportant\n\n\n\nParentheses (), brackets [] and braces {} all have different uses in R and care should be taken to apply them correctly.\n\n\n\n# Powers \n9^2\n\n[1] 81\n\n# Fractional Powers\n225^(1/2)\n\n[1] 15\n\n# Square Root Function\nsqrt(225)\n\n[1] 15\n\n\n\n\nLogarithms and Exponentials\nAs a quick reminder in mathematics we define the irrational number \\(e\\) by \\[\ne = 2.71828...\n\\]\nThe exponential function \\(\\exp(\\cdot)\\) is defined as \\[\n\\exp(x) = e^x.\n\\]\nThe inverse of this function is known as the natural logarithm \\(\\log(\\cdot)=\\ln(\\cdot)\\) and is defined as the power of which \\(e\\) will have to be raised to in order to give \\(x\\). It is therefore the inverse of the exponential function and satisfies \\[\n\\exp(\\log(x)) = e^{\\log(x)} = x.\n\\]\nFor a more indepth look at these functions and the results we use to perform calculations with them see my note on Log Laws. To apply these functions in R we use the exp() and log() functions:\n\n# Exponential function\nexp(1)\n\n[1] 2.718282\n\nexp(17)\n\n[1] 24154953\n\n# Log function\nlog(47)\n\n[1] 3.850148\n\n# Inverse example\nlog(exp(47))\n\n[1] 47\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\nVerify the following mathematical computations in R using the operations above:\n\n\\(\\left(\\frac{\\log(49^2)}{\\exp(4)}\\right)^{1/3}=0.5223981\\);\n\\(\\left(67+\\left(\\frac{12}{5} \\times \\frac{3}{12}\\right)\\right)^e+\\left(\\log(21) - \\sqrt{14}\\right)=94255.7\\)"
  },
  {
    "objectID": "posts/rds2-basics1-operators/index.html#logic",
    "href": "posts/rds2-basics1-operators/index.html#logic",
    "title": "R Basics I - Operators, Logic & Data Types",
    "section": "Logic",
    "text": "Logic\nR can also handle logical inputs including:\n\n&lt; less than;\n&lt;= less than or equal to;\n&gt; greater than;\n&gt;= greater than or equal to;\n== equal to;\n!= not equal to;\n& AND (\\(\\cap\\) written mathematically);\n| OR (\\(\\cup\\) written mathematically).\n\nWe can write a logical expression and the return will note whether the statement was true or false. For example, the output below is FALSE because the statement “4 is greater than or equal to 5” is false:\n\n# Logical example\n4 &gt;= 5\n\n[1] FALSE\n\n\nNote that to combine logical expressions we must use & or |! For example, trying to evaluate 2 &lt; 4 &lt; 5 will result in an error message."
  },
  {
    "objectID": "posts/rds2-basics1-operators/index.html#data-types",
    "href": "posts/rds2-basics1-operators/index.html#data-types",
    "title": "R Basics I - Operators, Logic & Data Types",
    "section": "Data Types",
    "text": "Data Types\nIf we were to save the output of the previous logical expression to an object b we would see in our environment tab that b is a boolean type. R has the capacity to handle multiple data types including:\n\nNumeric - split into two sub-categories:\n\nInteger - integer values i.e. whole numbers;\nDouble - decimal values (default over integer);\n\nBoolean / Logical - TRUE / FALSE output of some logical query;\nCharacter - Any number or character enclosed in '' or \"\".\n\nA sequential collection of characters forms a string e.g. \"datascience\" but note that this is not a specific datatype in R unlike other languages such as python.\n\n\n\n\n\n\nExercise 2\n\n\n\nWhat will the following logical queries output:\n\n5 &gt; 7\n10 &lt;= 10\n13 != 12\n\"Hello\" &gt;= \"Hell\"\n\"Hello\" != \"Hell\" | 5 &lt; 4\n3 &lt; 5 &lt; 7"
  },
  {
    "objectID": "posts/rds2-basics1-operators/index.html#assignment-operator",
    "href": "posts/rds2-basics1-operators/index.html#assignment-operator",
    "title": "R Basics I - Operators, Logic & Data Types",
    "section": "Assignment Operator",
    "text": "Assignment Operator\nThe assignment operator -&gt; is used to define objects in R, i.e. to store them in our short-term memory to use multiple times. Objects can take many different forms from basic numbers to vectors, matrices or even functions, all of which we detail in Chapter 3. For now, suppose we wish to store the results of some of the above computations for future use. We can do so by applying the assignment oeprator:\n\n# Define object a\na &lt;- (log(49^2)/exp(4))^(1/3)\n\nRunning this code you should see the object a appear in your environment tab and you might have noticed no result was printed in the console. To print the value of a in your console you can either use the print() function or just call the object in your console:\n\n# Print function\nprint(a)\n\n[1] 0.5223981\n\n# Call Object\na\n\n[1] 0.5223981\n\n\n\n  ← Previous Chapter \n  Next Chapter →"
  },
  {
    "objectID": "posts/rds4-basics3-dataframes/index.html#non-atomic-data-structures",
    "href": "posts/rds4-basics3-dataframes/index.html#non-atomic-data-structures",
    "title": "R Basics III - Dataframes and Lists",
    "section": "Non-Atomic Data Structures",
    "text": "Non-Atomic Data Structures\nSo far we have introduced a variety of atomic data structures (e.g. scalars, vectors, matrices and arrays) each of which are designed for ease of computation and interaction by being restricted to containing only one datatype. However, as any scientist who has ever collected data will tell you, we often need to define objects that contain multiple datatypes, namely:\n\nDataframes; and\nLists.\n\nBy containing multiple datatypes you sacrifice computationally tractability but gain immense flexibility for data storage."
  },
  {
    "objectID": "posts/rds4-basics3-dataframes/index.html#dataframes",
    "href": "posts/rds4-basics3-dataframes/index.html#dataframes",
    "title": "R Basics III - Dataframes and Lists",
    "section": "Dataframes",
    "text": "Dataframes\nIn R a dataframe can be intuitively pictured as a table of data where each column is of the same datatype. For example here is a table showing the first 6 rows of the pre-loaded dataframe iris which contains 4 numeric columns and one factor column:\n\n\n\n\n\nSepal.Length\nSepal.Width\nPetal.Length\nPetal.Width\nSpecies\n\n\n\n\n5.1\n3.5\n1.4\n0.2\nsetosa\n\n\n4.9\n3.0\n1.4\n0.2\nsetosa\n\n\n4.7\n3.2\n1.3\n0.2\nsetosa\n\n\n4.6\n3.1\n1.5\n0.2\nsetosa\n\n\n5.0\n3.6\n1.4\n0.2\nsetosa\n\n\n5.4\n3.9\n1.7\n0.4\nsetosa\n\n\n\n\n\n\nConstructing Dataframes\nTo construct a dataframe in R we can use the dataframe() function:\n\ndata.frame(..., row.names = NULL, check.rows = FALSE,\n           check.names = TRUE, fix.empty.names = TRUE,\n           stringsAsFactors = FALSE)\n\nThis function has multiple arguments but the most important are ..., row.names and stringsAsFactors. Lets go through a few examples of constructing data frames to build up our understanding.\nLets start by building a dataframe with three columns, the first containing numbers, the second containing boolean objects and the third containing character strings. To do so we specify each columns values in a vector ensuring all three vectors are of the same length to avoid an error message:\n\ndata &lt;- data.frame(\n    c(1,2,3),\n    c(TRUE, TRUE, FALSE),\n    c(\"alpha\", \"beta\", \"gamma\")\n)\ndata\n\n  c.1..2..3. c.TRUE..TRUE..FALSE. c..alpha....beta....gamma..\n1          1                 TRUE                       alpha\n2          2                 TRUE                        beta\n3          3                FALSE                       gamma\n\n\nLooking at our print out we note othat we have successfully created a dataframe with:\n\nNumbered rows from 1 to 3; and\nGenerated column names based on the vector inputs.\n\nWe can specify the names of the columns of the dataframe by slightly tweaking our code:\n\ndata &lt;- data.frame(\n    numbers = c(1,2,3),\n    booleans = c(TRUE, TRUE, FALSE),\n    strings = c(\"alpha\", \"beta\", \"gamma\")\n)\ndata\n\n  numbers booleans strings\n1       1     TRUE   alpha\n2       2     TRUE    beta\n3       3    FALSE   gamma\n\n\nWhat if we want to name the rows? In this case we can use the row.names argument as\n\ndata &lt;- data.frame(\n    numbers = c(1,2,3),\n    booleans = c(TRUE, TRUE, FALSE),\n    strings = c(\"alpha\", \"beta\", \"gamma\"),\n    row.names = c(\"first\", \"second\", \"third\")\n)\ndata\n\n       numbers booleans strings\nfirst        1     TRUE   alpha\nsecond       2     TRUE    beta\nthird        3    FALSE   gamma\n\n\nFinally, we can use the stringsAsFactors argument to specify that we wish to convert the strings column into a factor column:\n\ndata &lt;- data.frame(\n    numbers = c(1,2,3),\n    booleans = c(TRUE, TRUE, FALSE),\n    strings = c(\"alpha\", \"beta\", \"gamma\"),\n    row.names = c(\"first\", \"second\", \"third\"),\n    stringsAsFactors = TRUE\n)\ndata\n\n       numbers booleans strings\nfirst        1     TRUE   alpha\nsecond       2     TRUE    beta\nthird        3    FALSE   gamma\n\n\nThis does not change the dataframe visually but if we will see in the following section that it has changed the datatype of the strings column.\n\n\nIndexing Dataframes\nDataframe indexing behaves a lot like matrix indexing as discussed in R Basics II (Atomic Data Structures). We can use numerical indexing with dataframes by specifying the row \\(i\\) and column number \\(j\\) of the elements we wish to return inside braces []:\n\n# return the element in the 2nd row and 3rd column\ndata[2,3]\n\n[1] beta\nLevels: alpha beta gamma\n\n# return column 2\ndata[,2]\n\n[1]  TRUE  TRUE FALSE\n\n# return the second and third row for both columns 1 and 3\ndata[2:3, c(1,3)]\n\n       numbers strings\nsecond       2    beta\nthird        3   gamma\n\n\nAlternatively, we can specify the name of the column and rows using quotation marks ' ':\n\n# return the numbers column\ndata[\"numbers\"]\n\n       numbers\nfirst        1\nsecond       2\nthird        3\n\n# return the numbers column for the second row\ndata[\"second\", \"numbers\"]\n\n[1] 2\n\n\nA quick syntax for returning a specific column is $:\n\n# select the boolean column\ndata$booleans\n\n[1]  TRUE  TRUE FALSE\n\n\nAs with atomic data structures we can also filter values using logical statements but it is important to consider the datatypes being considered:\n\n# return the rows that have numbers == 2\ndata[data$numbers == 2,]\n\n       numbers booleans strings\nsecond       2     TRUE    beta\n\n# return the rows that have numbers == 1 or boolean == TRUE\ndata[data$numbers == 2 | data$booleans == TRUE,]\n\n       numbers booleans strings\nfirst        1     TRUE   alpha\nsecond       2     TRUE    beta"
  },
  {
    "objectID": "posts/blog1-qualification/index.html",
    "href": "posts/blog1-qualification/index.html",
    "title": "Update: Qualified at last!",
    "section": "",
    "text": "Over the past few months I have been working to prepare and submit an initial research report as part of my departments qualification requirements. Thanks to guidance from my supervisor Dr Ludkovski and helpful discussions with my reviewer Dr Ichiba I am grateful to say my report has been accepted and I am now qualified to work towards my advancement.\nIt has been a lot of work these first few years riddled with set backs and challenges but it is rewarding to finally feel confident about my direction moving forward. I feel more focussed and driven now that I have a clear goal and a project to focus my attention on.\nFor any graduate student still working towards this milestone just keep moving forward. I have been overwhelmed by feelings of inadequacy and imposter’s syndrome being surrounded by so many brilliant and smart students but I have found it more important to maintain a positive work ethic and to embrace doggedly trying to consistently improve. You might never be the smartest student in the department but you can always strive to be smarter than your past self.\n\n\n\nImage taken by Zekai Wu, find him on instagram at @pipikai."
  },
  {
    "objectID": "posts/blog1-qualification/index.html#updates",
    "href": "posts/blog1-qualification/index.html#updates",
    "title": "Update: Qualified at last!",
    "section": "",
    "text": "Over the past few months I have been working to prepare and submit an initial research report as part of my departments qualification requirements. Thanks to guidance from my supervisor Dr Ludkovski and helpful discussions with my reviewer Dr Ichiba I am grateful to say my report has been accepted and I am now qualified to work towards my advancement.\nIt has been a lot of work these first few years riddled with set backs and challenges but it is rewarding to finally feel confident about my direction moving forward. I feel more focussed and driven now that I have a clear goal and a project to focus my attention on.\nFor any graduate student still working towards this milestone just keep moving forward. I have been overwhelmed by feelings of inadequacy and imposter’s syndrome being surrounded by so many brilliant and smart students but I have found it more important to maintain a positive work ethic and to embrace doggedly trying to consistently improve. You might never be the smartest student in the department but you can always strive to be smarter than your past self.\n\n\n\nImage taken by Zekai Wu, find him on instagram at @pipikai."
  },
  {
    "objectID": "posts/rds4-basics3-dataframes/index.html#lists",
    "href": "posts/rds4-basics3-dataframes/index.html#lists",
    "title": "R Basics III - Dataframes and Lists",
    "section": "Lists",
    "text": "Lists\nLists are the most flexible data storage tool, allowing us to store scalars, matrices, arrays, dataframes or even other lists by some indexing or naming convention. We have already created a dataframe object data and in previous posts we used the following code to create scalars, vectors and matrices:\n\ny &lt;- \"scalar\"\nchar_vec &lt;- c(\"dog\", \"cat\", \"goose\", \"monkey\", \"elephant\")\nB &lt;- matrix(\n    seq(from=2, length.out=16, by=2), \n    nrow = 4, ncol = 4, byrow = TRUE\n    )\n\nTo create a list of these objects called object_list we naturally use the list() function:\n\nobject_list &lt;- list(\n    scalar = y,\n    vector = char_vec,\n    matrix = B,\n    dataframe = data\n)\n\nThis creates a list with 4 elements which we can access using double braces [[]], either using the specified name or the corresponding numerical index:\n\n# return the vector from the list\nobject_list[[\"vector\"]]\n\n[1] \"dog\"      \"cat\"      \"goose\"    \"monkey\"   \"elephant\"\n\n# return the third element from the list (the matrix)\nobject_list[[3]]\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    4    6    8\n[2,]   10   12   14   16\n[3,]   18   20   22   24\n[4,]   26   28   30   32\n\n\nWe typically only use lists for convenient data storage due to their restrictive structure making any computations impossible.\n\n  ← Previous Chapter \n  Next Chapter →"
  },
  {
    "objectID": "posts/rds5-probability-basics/index.html",
    "href": "posts/rds5-probability-basics/index.html",
    "title": "Fundamentals of Probability Theory",
    "section": "",
    "text": "This post contains notes for Chapter 5 of my course series Data Science with R covering some fundamentals of probability theory. The material in this note is focussed on developing intuitive understanding for those who perhaps do not have a formal mathematical background. For a more rigorous measure theoretic definitions see my notes on Probability Theory."
  },
  {
    "objectID": "courses/intro_to_data_science/index.html#information",
    "href": "courses/intro_to_data_science/index.html#information",
    "title": "Data Science with R",
    "section": "✏️ Information",
    "text": "✏️ Information\nWelcome to Data Science with R, a course providing an introduction on how to use the programming language R for data science and statistical modelling.\nThe aim of this course is to provide a thorough introduction to programming in R for individuals who may have never written or utilized a programming language before. First we outline how to install R on our operating system, how to download and use an Interactive Development Environment (IDE) such as RStudio, Positron or VSCode, and how to install packages on our system. We will then explore various ways to explore, manage and analyze data using both the in-built functionality in R as well as available libraries such as tidyverse."
  },
  {
    "objectID": "courses/intro_to_data_science/index.html#topics",
    "href": "courses/intro_to_data_science/index.html#topics",
    "title": "Data Science with R",
    "section": "✍️ Topics",
    "text": "✍️ Topics\nThis course is based fundamentally on the PSTAT10 Data Science Principles class I have taught in the past at UCSB. The course is split into the following topics:\n\nInstalling and using R and RStudio.\nR Basics I - Operators, Logic & Data Types.\nR Basics II - Atomic Data Structures.\nR Basics III - Dataframes and Lists\nR Basics IV - Functions\nR Basics V - Looping and Branching\nFundamentals of Probability Theory.\nBasic Simulation with R.\nData Handling with the tidyverse package.\nPlotting with ggplot2.\nSQL Basics.\nSQL Aggregation and Joins."
  },
  {
    "objectID": "courses/intro_to_data_science/index.html#materials",
    "href": "courses/intro_to_data_science/index.html#materials",
    "title": "Data Science with R",
    "section": "📚 Materials",
    "text": "📚 Materials\nEach topic links to a website post with the relevant material. A pdf copy of the combined course notes can be downloaded here. Furthermore, each wesite post links to the corresponding youtube video going through the material.\nFor this course you will need to download the language R, your chosen IDE and Quarto using the following links:\n\nLink to download R & RStudio\nLink to download Quarto\n\nSome helpful resources and additional guides and linked below:\n\nDocumentation: Quarto for PDF documents\nDocumentation: Writing maths using LaTeX\nDocumentation: Plotting with ggplot\n\nIf you found any of this material helpful consider buying me a coffee but only if you can afford to! Thank you for visiting this course page. 😊"
  },
  {
    "objectID": "posts/rds5-probability-basics/index.html#probability-theory",
    "href": "posts/rds5-probability-basics/index.html#probability-theory",
    "title": "Fundamentals of Probability Theory",
    "section": "Probability Theory",
    "text": "Probability Theory\nLet us begin like all good courses on the fundamentals of probability by considering the simple experiment of flipping a fair coin. This is a random experiment with finite and discrete outcomes, i.e. the results of the experiment can be either heads or tails and do not know which in advance. A collection of possible outcomes is known as an event, for example let us define the following 4 events:\n\nThe coin lands on heads \\(H\\);\nThe coin lands on tails \\(T\\);\nThe coin lands on heads and tails \\(H \\cap T\\); and\nThe coin lands on heads or tails \\(H \\cup T\\).\n\nThe probability of a discrete event \\(A\\) occuring is given by:\n\\[\n\\mathbb{P}(A) := \\frac{\\text{number of ways for }A\\text{ to occur}}{\\text{total number of possible outcomes}}\n\\]\nFor our coin flipping example we have 2 possible outcomes and thus\n\\[\n\\mathbb{P}(H)=\\mathbb{P}(T)=\\frac{1}{2}.\n\\]\nFurthermore, there are no ways for \\(H\\cap T\\) to occur so \\(\\mathbb{P}(H\\cap T)=0\\) and there are 2 ways for \\(H\\cup T\\) to occur so \\(\\mathbb{P}(H\\cup T)=\\frac{2}{2}=1\\)."
  },
  {
    "objectID": "posts/rds5-probability-basics/index.html#probability",
    "href": "posts/rds5-probability-basics/index.html#probability",
    "title": "Fundamentals of Probability Theory",
    "section": "Probability",
    "text": "Probability\nLet us begin like all good courses on the fundamentals of probability by considering the simple experiment of flipping a fair coin. This is a random experiment with finite and discrete outcomes, i.e. the results of the experiment can be either heads or tails and do not know which in advance.\nA collection of possible outcomes is known as an event, for example we define the event of the coin landing on heads by \\(H\\).\nThe probability of a discrete event \\(H\\) occuring is given by:\n\\[\n\\mathbb{P}(A) := \\frac{\\text{number of ways for }H\\text{ to occur}}{\\text{total number of possible outcomes}}\n\\]\nFor our coin flipping example we have 2 possible outcomes and thus\n\\[\n\\mathbb{P}(H)=\\mathbb{P}(T)=\\frac{1}{2}.\n\\]\n\n\n\n\n\n\nDefinition: Sample Space\n\n\n\nThe sample space for a random experiment, denoted by the capital Greek letter Omega \\(\\Omega\\), is the set of all possible outcomes of the experiment.\n\n\nA sample space is said to be discrete if it has finite (or more specifically countable) possible outcomes (e.g. coin flips, dice rolls). Otherwise, the sample space is said to be continuous (e.g. height of individuals measured, speed of birds).\nSince the sample space contains all outcomes and it is certain that something will happen we have that \\(\\mathbb{P}(\\Omega)=1\\). Equivalently, the probability of nothing happening, denoted by the empty set \\(\\emptyset\\), is \\(\\mathbb{P}(\\emptyset)=0\\). Finally, intuitively the probability of any event can never be negative, and can never be greater than 1, or written mathematically\n\\[\n\\forall A,~0\\leq \\mathbb{P}(A)\\leq 1.\n\\]\nThese fundamental properties are known as the probability axioms.\n\nProbability Zero Events\nWe note that when we are considering random experiments with continuous sample spaces, a probability zero event is not the same as that event being impossible. This might seem like a crazy thing to say but lets develop our intuition with an example.\nConsider the continuous interval \\([0,1]\\). Let us say that we have equal probability of choosing any real number (decimal of up to infinite length) in this interval. What is the probability that we select exactly \\(0.5\\)?\nYou would correctly say 0, we have uncountably infinite events and only one that we care about, hence this is a zero probability event.\nHowever, you could have chosen 0.5. In fact, you are certain to choose some number and whatever number you choose also was a probability zero event!\n\n\nVenn Diagrams\nTo visualize the probability of random experiments, and to gain an intuitive understanding of the underlying set theory notation, we can use Venn diagrams.\nTo consider a new and more interesting example, we turn to a fair 10-sided dice. The sample space is\n\\[\n\\Omega := \\{1,2,3,4,5,6,7,8,9,10\\}.\n\\]\nWe then define the events:\n\n\\(A\\) - roll a number less than 5; and\n\\(B\\) - roll a number greater than 3,\n\nwith probabilities\n\\[\n\\mathbb{P}(A)=\\frac{4}{10}=\\frac{2}{5}\\quad \\& \\quad \\mathbb{P}(B)=\\frac{7}{10}.\n\\]\n\n\n\n\n\nVenn Diagram of Set A and B"
  },
  {
    "objectID": "posts/rds5-probability-basics/index.html#sample-spaces",
    "href": "posts/rds5-probability-basics/index.html#sample-spaces",
    "title": "Fundamentals of Probability Theory",
    "section": "Sample Spaces",
    "text": "Sample Spaces\nThe sample space for a random experiment, denoted by the capital Greek letter Omega \\(\\Omega\\), is the set of all possible outcomes of the experiment.\nA sample space is said to be discrete if it has finite (or more specifically countable) possible outcomes (e.g. coin flips, dice rolls). Otherwise, the sample space is said to be continuous (e.g. height of individuals measured, speed of birds)."
  },
  {
    "objectID": "posts/rds5-probability-basics/index.html#venn-diagrams",
    "href": "posts/rds5-probability-basics/index.html#venn-diagrams",
    "title": "Fundamentals of Probability Theory",
    "section": "Venn Diagrams",
    "text": "Venn Diagrams\nTo visualize the probability of random experiments, and to gain an intuitive understanding of the underlying set theory notation, we can use Venn diagrams.\nTo consider a new and more intersting example, we turn to a fair 10-sided dice. The sample space is\n\\[\n\\Omega := \\{1,2,3,4,5,6,7,8,9,10\\}.\n\\]\nWe then define the events:\n\n\\(A\\) - roll a number less than 5; and\n\\(B\\) - roll a number greater than 3,\n\nwith probabilities\n\\[\n\\mathbb{P}(A)=\\frac{4}{10}=\\frac{2}{5}\\quad \\& \\quad \\mathbb{P}(B)=\\frac{7}{10}.\n\\]\n\n\n\n\n\nVenn Diagram of Set A and B"
  },
  {
    "objectID": "posts/rds5-probability-basics/index.html#probability-fundamental-results",
    "href": "posts/rds5-probability-basics/index.html#probability-fundamental-results",
    "title": "Fundamentals of Probability Theory",
    "section": "Probability Fundamental Results",
    "text": "Probability Fundamental Results\n\nMutual Exclusivity\nConsider two general events \\(A\\) and \\(B\\). We say that the events are mutually exclusive if they cannot happen at the same time, or written mathematically \\[\n\\mathbb{P}(A\\cap B) = 0.\n\\]\n\nThus, if two events are not mutually exclusive, they overlap when drawn as a Venn diagram.\n\n\n\nAddition Rule\nThe addition rule states that \\[\n\\mathbb{P}(A\\cup B)=\\mathbb{P}(A) + \\mathbb{P}(B) -\\mathbb{P}(A\\cap B),\n\\]\ni.e. the probabiity that event \\(A\\) or \\(B\\) occurs is equal to the sum of the probabilities that events \\(A\\) and \\(B\\) occur minus the probability that both events \\(A\\) and \\(B\\) occur.\n\n\nComplementary Events\nThe complement \\(A^c\\) of an event \\(A\\) means all outcomes besides those contained in \\(A\\).\n\nThus we have the helpful result \\[\n\\mathbb{P}(A^c)= 1-\\mathbb{P}(A).\n\\]\n\n\nConditional Events\nSometimes it is easier to think about the probability of an event \\(A\\) conditional on some other event \\(B\\). Formally written, the conditional probability of \\(A\\) occurring given that event \\(B\\) has occurred is \\[\n\\mathbb{P}(A|B) = \\frac{\\mathbb{P}(A\\cap B)}{\\mathbb{P}(B)}.\n\\]\n\n\nIndependent Events\nTwo events \\(A\\) and \\(B\\) are said to be independent if \\[\n\\mathbb{P}(A|B)=\\mathbb{P}(A).\n\\]\nNote that this also allows us to obtain the equivalent definition: \\[\n\\mathbb{P}(A|B)=\\frac{\\mathbb{P}(A\\cap B)}{\\mathbb{P}(B)}=\\mathbb{P}(A)\\implies\\mathbb{P}(A\\cap B)=\\mathbb{P}(A)\\times\\mathbb{P}(B).\n\\]"
  },
  {
    "objectID": "posts/rds5-probability-basics/index.html#probability-laws",
    "href": "posts/rds5-probability-basics/index.html#probability-laws",
    "title": "Fundamentals of Probability Theory",
    "section": "Probability Laws",
    "text": "Probability Laws\n\nMutual Exclusivity\nConsider two general events \\(A\\) and \\(B\\). We say that the events are mutually exclusive if they cannot happen at the same time, or written mathematically \\[\n\\mathbb{P}(A\\cap B) = 0.\n\\]\n\nThus, if two events are not mutually exclusive, they overlap when drawn as a Venn diagram.\n\n\n\nAddition Rule\nThe addition rule states that \\[\n\\mathbb{P}(A\\cup B)=\\mathbb{P}(A) + \\mathbb{P}(B) -\\mathbb{P}(A\\cap B),\n\\]\ni.e. the probabiity that event \\(A\\) or \\(B\\) occurs is equal to the sum of the probabilities that events \\(A\\) and \\(B\\) occur minus the probability that both events \\(A\\) and \\(B\\) occur.\n\n\nComplementary Events\nThe complement \\(A^c\\) of an event \\(A\\) means all outcomes besides those contained in \\(A\\).\n\nThus we have the helpful result \\[\n\\mathbb{P}(A^c)= 1-\\mathbb{P}(A).\n\\]\n\n\nConditional Events\nSometimes it is easier to think about the probability of an event \\(A\\) conditional on some other event \\(B\\). Formally written, the conditional probability of \\(A\\) occurring given that event \\(B\\) has occurred is \\[\n\\mathbb{P}(A|B) = \\frac{\\mathbb{P}(A\\cap B)}{\\mathbb{P}(B)}.\n\\]\n\n\nIndependent Events\nTwo events \\(A\\) and \\(B\\) are said to be independent if \\[\n\\mathbb{P}(A|B)=\\mathbb{P}(A).\n\\]\nNote that this also allows us to obtain the equivalent definition using the definition of conditional probability: \\[\n\\mathbb{P}(A|B)=\\frac{\\mathbb{P}(A\\cap B)}{\\mathbb{P}(B)}=\\mathbb{P}(A)\\implies\\mathbb{P}(A\\cap B)=\\mathbb{P}(A)\\times\\mathbb{P}(B).\n\\]\n\n\nBayes Theorem\nThe fundamental result of Bayesian statistics is Bayes theorem which states that \\[\n\\mathbb{P}(A|B)=\\frac{\\mathbb{P}(B|A)\\mathbb{P}(A)}{\\mathbb{P}(B)}.\n\\]"
  },
  {
    "objectID": "posts/rds5-probability-basics/index.html#random-variables",
    "href": "posts/rds5-probability-basics/index.html#random-variables",
    "title": "Fundamentals of Probability Theory",
    "section": "Random Variables",
    "text": "Random Variables\nIntuitively, a random variable \\(X\\) is a function that takes values in a support (some prespecified range of values) with some given probability. We often denote random variables with capital letter \\(X\\), \\(Y\\) or \\(Z\\).\nIf the support of a random variable is countable then the random variable is said to be discrete, otherwise it is said to be continuous.\n\nDiscrete Random Variables\nConsider a discrete random variable \\(X\\) that has countable support. We define the probability mass function (PMF) \\(p_X(x)\\) of the random variable by \\[\np_X(x)=\\mathbb{P}(X=x),\n\\]\ni.e. the probability mass function gives the probabilities of the random variable taking certain values in its support. From the PMF we can define the cumulative distribution function as \\[\nF_X(x)=\\mathbb{P}(X\\leq x).\n\\]\nFor example, let \\(X\\) be a random variable describing a fair 6-sided dice. Thus \\(X\\) has support \\(\\{1,2,3,4,5,6\\}\\) and its PMF can be summarised as \\[\n\\mathbb{P}(X=x)=\\frac{1}{6}~~\\forall x\\in\\{1,2,3,4,5,6\\}.\n\\]\nWe say that \\(X\\) follows a discrete uniform distribution and this is one example of a discrete distribution family. The common discrete distributions we will explore include:\n\nBernoulli Distribution;\nBinomial Distribution;\nDiscrete Uniform Distribution;\nPoisson Distribution.\n\n\nDiscrete Expectation\nThe expectation of a random variable gives the average of all values generated by the random variable under repeated sampling. For a discrete random variable this is given by the weighted sum \\[\n\\mathbb{E}[X] = \\sum_{x}x\\cdot\\mathbb{P}(X=x).\n\\]\nReturning to our example, we can compute the expectation of the discrete unform random variable as \\[\n\\begin{align}\n\\mathbb{E}[X] & = \\sum_{x=1}^6 x\\cdot\\mathbb{P}(X=x) \\\\\n& = \\frac{1}{6}\\cdot (1+2+3+4+5+6) = 21/6 = 3.5.\n\\end{align}\n\\]\n\n\n\nContinuous Random Variables\nNow consider a continuous random variable \\(X\\) taking values in some continuous support. Notice now that it would be non-sensical to try to define a mass function as above since \\(\\mathbb{P}(X=x)=0\\) for all \\(x\\). We instead must define a function \\(f_X(x)\\) known as the probability density function which gives the density of \\(X\\) across its support.\nTo improve our intuition about what a density function is, let us find the density function for a continuous random variable using probability laws. Let \\(X\\) be continuous and take values in the interval \\([0,10]\\) with equal probability. The density must be the same across all values of \\(x\\) and so we need can state that for some constant \\(c\\) \\[\nf(x)=c;~~\\forall x.\n\\]\nFurther the “sum” of the probabilities of all values must equal 1. Since we are “summing” over a continuous interval we instead use integration, i.e. we have that \\[\n\\int_0^{10}f_X(x)dx = \\int_0^{10}cdx =  1.\n\\]\nSome simple calculus gives us that \\[\n[cx]_{x=0}^{10}=10c=1\\implies c=\\frac{1}{10}.\n\\]\nThus the density can be summarized as \\[\nf_X(x) = \\frac{1}{10};~~\\forall x\\in [0,10].\n\\]\nThis is an example of a continuous uniform distribution. The standard continuous probability distributions we shall be considering include:\n\nContinuous Uniform Distribution;\nExponential Distribution;\nNormal Distribution.\n\nThe cumulative distribution function is defined as \\[\nF_X(x) := \\mathbb{P}(X\\leq x) =  \\int_{0}^x f_X(x)dx.\n\\]\nThus, in the continuous setting we can only compute the probability of intervals of the support.\n\nContinuous Expectation\nSimilarly, the continuous expectation is intuitively just the infinite weighted sum (i.e. an integral) defined as \\[\n\\mathbb{E}[X] := = \\int_X x dF(x) = \\int_X x\\cdot f_X(x) dx.\n\\]\nFor our example we can compute the expectation as \\[\n\\mathbb{E}[X] = \\int_{0}^{10} x\\cdot \\frac{1}{10} dx = \\left[\\frac{x^2}{20}\\right]_{x=0}^{10} = \\frac{100}{20} = 5.\n\\]"
  }
]