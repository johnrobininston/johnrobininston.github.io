<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="John Robin Inston">
<meta name="dcterms.date" content="2026-02-12">

<title>Markov Chains – John Robin Inston</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../assets/favicon-new.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-707d8167ce6003fca903bfe2be84ab7f.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-5100b8561cd7f6cd8c35657ed6fe7ee7.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">John Robin Inston</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../resume.html"> 
<span class="menu-text">Resume</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../topics.html"> 
<span class="menu-text">Topics</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.youtube.com/@JohnRobinInston"> <i class="bi bi-youtube" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/johnrobininston"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/johninston/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://x.com/John_Inston"> <i class="bi bi-twitter-x" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Markov Chains</h1>
            <p class="subtitle lead">Markov property, transition probabilities, state distributions, chain classification, Chapman-Kolmogorov equations and limiting distributions.</p>
                                <div class="quarto-categories">
                <div class="quarto-category">Stochastic Processes</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>John Robin Inston </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 12, 2026</p>
      </div>
    </div>
    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">February 12, 2026</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#markov-chains" id="toc-markov-chains" class="nav-link active" data-scroll-target="#markov-chains">Markov Chains</a>
  <ul class="collapse">
  <li><a href="#markov-property" id="toc-markov-property" class="nav-link" data-scroll-target="#markov-property">Markov Property</a></li>
  <li><a href="#markov-chains-1" id="toc-markov-chains-1" class="nav-link" data-scroll-target="#markov-chains-1">Markov Chains</a></li>
  <li><a href="#transition-diagrams" id="toc-transition-diagrams" class="nav-link" data-scroll-target="#transition-diagrams">Transition Diagrams</a></li>
  <li><a href="#state-distributions" id="toc-state-distributions" class="nav-link" data-scroll-target="#state-distributions">State Distributions</a></li>
  </ul></li>
  <li><a href="#mc-classification" id="toc-mc-classification" class="nav-link" data-scroll-target="#mc-classification">MC Classification</a>
  <ul class="collapse">
  <li><a href="#state-classification" id="toc-state-classification" class="nav-link" data-scroll-target="#state-classification">State Classification</a></li>
  <li><a href="#chain-classification" id="toc-chain-classification" class="nav-link" data-scroll-target="#chain-classification">Chain Classification</a></li>
  </ul></li>
  <li><a href="#chapman-kolmogorov-equations" id="toc-chapman-kolmogorov-equations" class="nav-link" data-scroll-target="#chapman-kolmogorov-equations">Chapman Kolmogorov Equations</a></li>
  <li><a href="#limiting-distributions" id="toc-limiting-distributions" class="nav-link" data-scroll-target="#limiting-distributions">Limiting Distributions</a>
  <ul class="collapse">
  <li><a href="#limiting-distribution" id="toc-limiting-distribution" class="nav-link" data-scroll-target="#limiting-distribution">Limiting Distribution</a></li>
  <li><a href="#stationary-distribution" id="toc-stationary-distribution" class="nav-link" data-scroll-target="#stationary-distribution">Stationary Distribution</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">






<section id="markov-chains" class="level2">
<h2 class="anchored" data-anchor-id="markov-chains">Markov Chains</h2>
<section id="markov-property" class="level3">
<h3 class="anchored" data-anchor-id="markov-property">Markov Property</h3>
<p>In probability theory a stochastic process is said to satisfy the <mark><em>Markov property</em></mark> if its future evolution is <mark><em>independent of its history</em></mark>, that is, the process is <mark><em>memoryless</em></mark>. Consider a discrete time stochastic process <span class="math inline">\(\{X_t\}_{t\in\mathbb{N}}\)</span> defined in the probability space <span class="math inline">\((\Omega,\mathcal{F}, \mathbb{P})\)</span>.</p>
<blockquote class="blockquote">
<p><strong>Definition:</strong> (<mark><strong>Markov Property</strong></mark>)<br>
The discrete time stochastic process <span class="math inline">\(\{X_t\}_{t\in\mathbb{N}}\)</span> is said to satisfy the <em>Markov property</em> if <span class="math display">\[\mathbb{P}(X_{n+1}=x_{n+1}|X_n=x_n, ..., X_1=x_1)=\mathbb{P}(X_{n+1}=x_{n+1}|X_n=x_n).\]</span></p>
</blockquote>
<p>Intuitively, we see that we gain no additional information about the probability of the next value of the process by conditioning on the entire history rather than the latest value. Any process satisfying the markov property is called a <mark><strong>Markov process</strong></mark>.</p>
</section>
<section id="markov-chains-1" class="level3">
<h3 class="anchored" data-anchor-id="markov-chains-1">Markov Chains</h3>
<p>A Markov process with a discrete state space is known as a <mark><strong>Markov chain (MC)</strong></mark>. Assume that <span class="math inline">\(\{X_t\}_{t\in\mathbb{N}}\)</span> is a Markov chain with finite state space <span class="math inline">\(\mathcal{X}:=\{1, ..., M\}\)</span>. The evolution of the chain in time is described by <mark><strong>transition probabilities</strong></mark> <span class="math inline">\(p_{i,j}^{(n)}(t)\)</span> which give the probability that the chain is in state <span class="math inline">\(j\)</span> at time <span class="math inline">\(t+n\)</span> given that the chain was in <span class="math inline">\(i\)</span> at time <span class="math inline">\(t\)</span> <span class="math display">\[
p_{i,j}^{(n)}(t)=\mathbb{P}(X_{t+n}=j|X_{t}=i).
\]</span></p>
<p>We summarize the transition probabilities in an <span class="math inline">\(M\times M\)</span> <mark><strong>transition probability matrix</strong></mark> denoted by <span class="math display">\[
P^{(n)}(t)=(p_{i,j}^{(n)}(t))_{i,j\in\mathcal{X}}.
\]</span></p>
<p>The transition probability matrix is <mark><em>stochastic</em></mark> which means that for all <span class="math inline">\(n,t\in\mathbb{N}\)</span> we have:</p>
<ol type="1">
<li><span class="math inline">\(0\leq p_{i,j}^{(n)}(t)&lt;1\)</span> for all <span class="math inline">\(i,j\in \mathcal{X}\)</span>,</li>
<li><span class="math inline">\(\sum_{{j\in S}}p_{{i,j}}^{(n)}(t)=1\)</span> for all <span class="math inline">\(i\in \mathcal{X}\)</span> (the rows sum to 1).</li>
</ol>
<p>To simplify notation we denote the <mark><em>one-step transition probablity matrix</em></mark><br>
<span class="math display">\[
P(t)=(p_{i,j}(t))_{i,j\in\mathcal{X}}.
\]</span></p>
<p>The transition probabilities are <mark><em>stationary</em></mark> when they are invariant in time, that is <span class="math display">\[
p_{i,j}^{(n)}(t)=p_{i,j}^{(n)}(s);~~\forall s,t\in\mathbb{N}.
\]</span></p>
<p>We say that a MC is <mark><strong>homogenous</strong></mark> if it has stationary transition probabilities. For homogenous MCs we are often interested in the <mark>one-step transition probabilities</mark> and so again to clarify notation we denote the one-step transition probability matrix for homogenous MCs as <span class="math display">\[
P=(p_{i,j})_{i,j\in\mathcal{X}}.
\]</span></p>
<p><strong>Example:</strong> Consider a homogenous MC <span class="math inline">\(\{X_t\}\)</span> with finite state space <span class="math inline">\(\mathcal{S}:=\{1,2,3\}\)</span> with transition probability matrix <span class="math display">\[
P = \begin{bmatrix}
0 &amp; 0.6 &amp; 0.2 &amp; 0.2 \\
0.75 &amp; 0 &amp; 0.25 &amp; 0 \\
0.25 &amp; 0.25 &amp; 0.25 &amp; 0.25 \\
0.25 &amp; 0 &amp; 0.25 &amp; 0.5
\end{bmatrix}.
\]</span></p>
</section>
<section id="transition-diagrams" class="level3">
<h3 class="anchored" data-anchor-id="transition-diagrams">Transition Diagrams</h3>
<p>To gain deeper insight into the behavior of the chain we typically will produce <mark><em>transition probability diagram</em></mark> which takes the form of a directed graph with nodes denoting states and weighted directed arrows the transition probabilities. The transition probability diagram for our example is</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/transition-probability-diagram.png" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>Transition probability diagram.</figcaption>
</figure>
</div>
<p>There are several alternate versions of this diagram including the <mark><em>integer weighted diagram</em></mark>. To construct the integer-weighted diagram we compute the inter-weighted matrix by multiplying elements of each row by the lowest common multiple for that row. The integer weighted matrix for our example is <span class="math display">\[
P = \begin{bmatrix}
0 &amp; 3 &amp; 1 &amp; 1 \\
3 &amp; 0 &amp; 1 &amp; 0 \\
1 &amp; 1 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 1 &amp; 2
\end{bmatrix}.
\]</span></p>
<p>The corresponding diagram is</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/iw-transition-probability-diagram.png" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>Integer-weighted transition probability diagram.</figcaption>
</figure>
</div>
<p>Since our diagram has a symmetric integer-weighted transition matrix we can also write the <mark><em>non-directed version</em></mark> by combining the equally weighted directed arrows into a single non-directed line</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/iwnd-transition-probability-diagram.png" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>Integer-weighted non-directed ransition probability diagram.</figcaption>
</figure>
</div>
</section>
<section id="state-distributions" class="level3">
<h3 class="anchored" data-anchor-id="state-distributions">State Distributions</h3>
<p>The <mark><strong>state distribution</strong></mark> <span class="math inline">\(\mu_i(t)\)</span> gives the probability that the chain is in state <span class="math inline">\(i\)</span> at time <span class="math inline">\(t\)</span> <span class="math display">\[
\mu_i(t)=\mathbb{P}(X_{t}=i).
\]</span></p>
<p>For convenience we summarize the state distributions in vector notation <span class="math display">\[
\boldsymbol{\mu}(t)=(\mu_i(t))_{i \in \mathcal{X}}.
\]</span></p>
<p>Of particular interest is the <mark><strong>initial state distribution</strong></mark> <span class="math display">\[
\boldsymbol{\mu}(0)=\boldsymbol{\mu}=(\mu_i(0))_{i \in\mathcal{X}}.
\]</span></p>
<p>For conveinence we also introduce the following notation for process vectors <span class="math display">\[
X_{1:t} = (X_1, ..., X_t),
\]</span></p>
<p>where similarly <span class="math inline">\(X_{1:t}=x_{1:t}\)</span> is equivalent to <span class="math inline">\(X_1=x_1, ..., X_t=x_t\)</span>.</p>
<p><mark><em>Finite-dimensional distributions</em></mark> allow us to evaluate the behavior of the distribution of infinite length processes by selecting some sub-sequence of index values to evaluate their joint distribution.</p>
<blockquote class="blockquote">
<p><strong>Proposition (<mark>Finite-Dimensional Distributions</mark>):</strong><br>
The <em>finite-dimensional distributions</em> of <span class="math inline">\(X=(X_{n})_{n}\)</span> are determined by the initial mass <span class="math inline">\(\mu^{(0)}\)</span> and transition matrix <span class="math inline">\(P\)</span> where <span class="math display">\[P(X_{0}=i_{0}, \dots, X_{n}=i_{n})=\mu_{{x_{0}}}^{(0)}p_{x_{0}, x_{1}}(0)p_{x_{1}, x_{2}}(1)\cdots p_{x_{n-1}, x_{n}}(n-1).\]</span></p>
</blockquote>
<p><strong>Proof:</strong><br>
From application of the Chain Rule and the Markov Property we see that <span class="math display">\[
\begin{align}  
\mathbb{P}&amp;(X_{1 : n}=x_{1: n}) &amp; \\
&amp; = \mathbb{P}(X_{0}=x_{0}) \mathbb{P}(X_{1}=x_{1}|X_{0}=x_{0})\mathbb{P}(X_{2}=x_{2}|X_{0 : 1}=x_{0 : 1})\cdots \\
&amp; \quad \cdots \mathbb{P}(X_{n}=x_{n}|X_{0 : n-1}=x_{0: n-1})  \\
  &amp; =\mathbb{P}(X_{0}=x_{0})\mathbb{P}(X_{1}=x_{1}|X_{0}=x_{0})\mathbb{P}(X_{2}=x_{2}|X_{1}=x_{1})\cdots \\
  &amp; \quad \cdots \mathbb{P}(X_{n}=x_{n}|X_{n-1}=x_{n-1})  \\
&amp; = \mu_{{x_{0}}}^{(0)}p_{x_{0}, x_{1}}(0)p_{x_{1}, x_{2}}(1)\cdots p_{x_{n-1}, x_{n}}(n-1),
\end{align}
\]</span></p>
<p>as required.<br>
<span class="math inline">\(\square\)</span></p>
<blockquote class="blockquote">
<p><strong>Proposition: (<mark>Multi-step Transition Probabilities for homogenous MCs</mark>)</strong><br>
Let <span class="math inline">\(\{ X_{n} \}\)</span> be a homogenous MC with one-step transition probability matrix <span class="math inline">\(P\)</span>. The <span class="math inline">\(m\)</span>-step transition probabilities are given by raising the one-step transition probability matrix to the <span class="math inline">\(m\)</span>-th power <span class="math display">\[P^{(m)}=(\mathbb{P}(X_{m}=j|X_{0}=i))_{i,j}=P^m.\]</span></p>
</blockquote>
<p><strong>Proof:</strong><br>
The result follows immediately from the Markov property since <span class="math display">\[
\begin{aligned}
\mathbb{P}(X_{m}|X_{0}) &amp; =\mathbb{P}(X_{m}|X_{m-1})\mathbb{P}(X_{m-1}|X_{0}) \\
&amp; = \qquad \vdots \\
&amp; = \mathbb{P}(X_{m}|X_{m-1})\cdots \mathbb{P}(X_{1}|X_{0}) \\
&amp; = [\mathbb{P}(X_{1}|X_{0})]^m.
\end{aligned}
\]</span></p>
<p><span class="math inline">\(\square\)</span></p>
<p><em><strong>Example 1:</strong> Consider a homogenous MC with state space <span class="math inline">\(\mathcal{S}:=\{ 1,2,3 \}\)</span> with transition probability matrix <span class="math inline">\(P\)</span> and initial state distribution <span class="math inline">\(\mu\)</span> given respectively by <span class="math display">\[
P:=\begin{bmatrix}
0.4 &amp; 0.6 &amp; 0 \\
0.7 &amp; 0.3 &amp; 0  \\
0 &amp; 0.1 &amp; 0.9
\end{bmatrix},~~\mu=\begin{bmatrix}
0.1 &amp; 0.2 &amp; 0.7
\end{bmatrix}.
\]</span></em></p><em>
<p>The transition probability diagram for this chain is</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/state-diagram.jpeg" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>Transition Probability Diagram.</figcaption>
</figure>
</div>
<p>Suppose we wish to determine the <span class="math inline">\(3\)</span>-step transition probabilities. Applying Proposition 1 we can compute <span class="math inline">\(\mathbb{P}(X_3|X_0)\)</span> as <span class="math inline">\(P^3\)</span>:</p>
<div id="f2544d69" class="cell" data-execution_count="2">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>P <span class="op">=</span> np.array([</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">.4</span>, <span class="fl">.6</span>, <span class="dv">0</span>],</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">.7</span>, <span class="fl">.3</span>, <span class="dv">0</span>],</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="fl">.1</span>, <span class="fl">.9</span>]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>P3 <span class="op">=</span> np.linalg.matrix_power(P,<span class="dv">3</span>)<span class="op">;</span> <span class="bu">print</span>(P3)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[0.526 0.474 0.   ]
 [0.553 0.447 0.   ]
 [0.112 0.159 0.729]]</code></pre>
</div>
</div>
<p>Furthermore, let us suppose that we wish to determine the 3-step state distribution. From the finite-dimensional distribution we see that <span class="math display">\[
\begin{aligned}
\mathbb{P}(X_3) &amp; =\mathbb{P}(X_0)\mathbb{P}(X_1|X_0)\mathbb{P}(X_2|X_1)\mathbb{P}(X_3|X_2) \\
&amp; = \boldsymbol{\mu}P^3.
\end{aligned}
\]</span></p>
<p>Thus we can compute:</p>
<div id="97eaefd0" class="cell" data-execution_count="3">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> np.array([</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.7</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>mu<span class="op">@</span>(P3)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>array([0.2416, 0.2481, 0.5103])</code></pre>
</div>
</div>
</em><p><em></em></p>
</section>
</section>
<section id="mc-classification" class="level2">
<h2 class="anchored" data-anchor-id="mc-classification">MC Classification</h2>
<section id="state-classification" class="level3">
<h3 class="anchored" data-anchor-id="state-classification">State Classification</h3>
<p>We can classify MC states based on how they appear in the chain and their behavior in the limit. States can be <em>persistent</em> (<em>recurrent</em>), <em>null-persistent</em>, <em>transient</em>, <em>absorbing</em>, <em>periodic</em> and <em>ergodic</em>.</p>
<blockquote class="blockquote">
<p><strong>Definition: (<mark>Persistent States</mark>)</strong> A state <span class="math inline">\(j\)</span> is <em>persistent</em> if the probability that the process will return to <span class="math inline">\(j\)</span> given that it started at <span class="math inline">\(j\)</span> eventually is 1, that is <span class="math display">\[\mathbb{P}(X_{n}=j~\text{for some}~n\geq 1|X_{0}=j)=1.\]</span></p>
</blockquote>
<p>A sub-class of persistent states are <mark><em>null-persistent states</em></mark> which are persistent thats that have an infinite mean recurrence time. States that are not null-persistent are said to be <mark><em>positive_persistent</em></mark>.</p>
<p>For example, consider a symmetric random walk. Any point in the state space is null-persistent since the random walk can always return but may take infinitely long to do so. We discuss null-persistent states in a later note on MCs.</p>
<blockquote class="blockquote">
<p><strong>Definition: (<mark>Transient States</mark>)</strong><br>
Alternatively, if a state <span class="math inline">\(j\)</span> is not persistent it must be <em>transient</em>, that is, the probability that the process will return to <span class="math inline">\(j\)</span> given that it started at <span class="math inline">\(j\)</span> eventually is 0 i.e.&nbsp;the processes structure prevents it from returning. This is equivalent to writing <span class="math display">\[\mathbb{P}(X_{n}=i~\text{for some}~n\geq 1|X_{0}=i)&lt;1.\]</span></p>
</blockquote>
<blockquote class="blockquote">
<p><strong>Definition: (<mark>Periodic States</mark>)</strong><br>
The <em>period</em> of a state <span class="math inline">\(j\)</span> is the greatest common divider of all <span class="math inline">\(n\)</span> for which <span class="math inline">\(p_{{i,i}}(n)&gt;0\)</span> i.e.&nbsp; <span class="math display">\[d(i)=gcd\{n:p_{i,i}(n)&gt;0\}.\]</span> If <span class="math inline">\(d(i)=1\)</span> then the state <span class="math inline">\(j\)</span> is <em>aperiodic</em> and otherwise, the state is said to be <em>periodic</em>.</p>
</blockquote>
<blockquote class="blockquote">
<p><strong>Definition: (<mark>Ergodic</mark>)</strong><br>
A state <span class="math inline">\(j\)</span> is <mark><em>ergodic</em></mark> if it is positive persistent and aperiodic i.e.&nbsp;<span class="math inline">\(\mu_{i,i}&lt;\infty\)</span> and <span class="math inline">\(d(i)=1\)</span>.</p>
</blockquote>
<blockquote class="blockquote">
<p><strong>Definition: (<mark>Absorbing</mark>)</strong><br>
A state <span class="math inline">\(j\)</span> is <mark><em>absorbing</em></mark> if <span class="math inline">\(p_{j,j}=1\)</span>, that is the probability of leaving state <span class="math inline">\(j\)</span> once the process has entered is 0.</p>
</blockquote>
</section>
<section id="chain-classification" class="level3">
<h3 class="anchored" data-anchor-id="chain-classification">Chain Classification</h3>
<p>To classify chains we first define state <mark><em>communication</em></mark>, that is when paths between states have non-zero probability.</p>
<blockquote class="blockquote">
<p><strong>Definition: (<mark>Communicating States</mark>)</strong><br>
For MC <span class="math inline">\(\{ X_{t} \}\)</span> state <span class="math inline">\(i\)</span> <em>communicates</em> with state <span class="math inline">\(j\)</span>, denoted <span class="math inline">\(i \to j\)</span>, if <span class="math inline">\(p_{i,j}(n)&gt;0\)</span> for some <span class="math inline">\(n\)</span>. If <span class="math inline">\(i\to j\)</span> and <span class="math inline">\(j \to i\)</span> we say that <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> <em>intercommunicate</em>, denoted <span class="math inline">\(i \leftrightarrow j\)</span>.</p>
</blockquote>
<p>We can show that intercommunication is an <mark><em>equivalence class</em></mark> and thus can be used to split MC state spaces into communication classes. For <span class="math inline">\(i,j\)</span> in the same communication class we have:</p>
<ol type="1">
<li><p>States <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> have the same period;</p></li>
<li><p>State <span class="math inline">\(i\)</span> is transient iff <span class="math inline">\(j\)</span> is transient; and</p></li>
<li><p>State <span class="math inline">\(i\)</span> is null persistent iff <span class="math inline">\(j\)</span> is.</p></li>
</ol>
<blockquote class="blockquote">
<p><strong>Definition: (<mark>Irreducibility</mark>)</strong><br>
A set of states <span class="math inline">\(C\)</span> is <mark><em>irreducible</em></mark> if for all <span class="math inline">\(i,j\in C\)</span>, <span class="math inline">\(i\leftrightarrow j\)</span>, that is all states within <span class="math inline">\(C\)</span> inter-communicate.</p>
</blockquote>
<blockquote class="blockquote">
<p><strong>Definition: (<mark>Closed</mark>)</strong><br>
A set of states <span class="math inline">\(C\)</span> is <mark><em>closed</em></mark> if for all <span class="math inline">\(i \in C\)</span>, <span class="math inline">\(p_{i,j}=0\)</span> for all <span class="math inline">\(j\not\in C\)</span>, that is, the chain never leaves <span class="math inline">\(C\)</span> once it has entered. Not that clearly the set consisting of one absorbing state is closed.</p>
</blockquote>
<p><em></em></p><em>
<p><strong>Example:</strong> Consider the MC transition diagram shown in the figure below.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/complicated-transition-graph.png" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>Example transition probability diagram.</figcaption>
</figure>
</div>
<p>We define <span class="math inline">\(S_1:=\{5\}\)</span>, <span class="math inline">\(S_2:=\{1,2,3,4\}\)</span> and <span class="math inline">\(S_3:=\{6,7\}\)</span>. The chain is clearly reducible since <span class="math inline">\(2\to 5\)</span> and <span class="math inline">\(3\to 6\)</span> are one way journies. We can see that <span class="math inline">\(5\)</span> is absorbing since the chain can never leave once it arrives. We see that states <span class="math inline">\(1,2,3,4\)</span> are transient since the chain will visit them and never return at some point, and states <span class="math inline">\(6\)</span> and <span class="math inline">\(7\)</span> are recurrent since the chain will always revisit them. We say that <span class="math inline">\(S_1\)</span> is an closed recurrent (absorbing) class, <span class="math inline">\(S_2\)</span> is a transient class and <span class="math inline">\(S_3\)</span> is a closed recurrent class.</p>
</em><p><em></em></p>
</section>
</section>
<section id="chapman-kolmogorov-equations" class="level2">
<h2 class="anchored" data-anchor-id="chapman-kolmogorov-equations">Chapman Kolmogorov Equations</h2>
<p>The <mark><em>Chapman-Kolmogorov Equations (CKE)</em></mark> relate the joint probability distributions of different sets of coordinates on a stochastic process.</p>
<blockquote class="blockquote">
<p><strong>Theorem 2: (<mark>Chapman-Kolmogorov Equations</mark>)</strong><br>
For a discrete time countable state homogeneous Markov chain the Chapman-Kolmogorov equations state that <span class="math display">\[P_{n+m}=P_{n}\cdot P_{m},\]</span> or equivalently <span class="math display">\[p^{(n+m)}_{i,j}=\sum_{k\in S}p^{(n)}_{i,k}p^{(m)}_{k,j}.\]</span></p>
</blockquote>
<p>A similar result holds for distributions <span class="math display">\[
\mu_{j}^{(n+m)}=\sum_{i \in S}\mu_{i}^{(n)}p_{i,j}(m),
\]</span></p>
<p>or in matrix form <span class="math display">\[
\boldsymbol{\mu}^{(n+m)}=\boldsymbol{\mu}^{(n)}P_{m}=\boldsymbol{\mu}^{(n)}P^m\quad\&amp;\quad \boldsymbol{\mu}^{(n)}=\boldsymbol{\mu}^{(0)}P^n.
\]</span></p>
</section>
<section id="limiting-distributions" class="level2">
<h2 class="anchored" data-anchor-id="limiting-distributions">Limiting Distributions</h2>
<section id="limiting-distribution" class="level3">
<h3 class="anchored" data-anchor-id="limiting-distribution">Limiting Distribution</h3>
<p>Consider the long-term behavior of a MC <span class="math inline">\(\{ X_{n} \}_{n=0}^\infty\)</span> when <span class="math inline">\(n \to \infty\)</span>. It is possible for the chain to converge to a particular state (e.g.&nbsp;a Galton-Watson-Bienaymé (GWB) Branching Process can converge to 0). Additionally, it is possible for a MC to converge to some random variable <span class="math inline">\(X~a.s.\)</span> as <span class="math inline">\(n\to \infty\)</span>. Intuitively, if a Markov chain runs for a long time it generally doesn’t converge because it is always jumping around but its distribution can settle down.</p>
<blockquote class="blockquote">
<p><strong>Definition: (<mark>Limiting Distribution</mark>)</strong> The <em>limiting distribution</em> of a homogenous MC with initial distribution <span class="math inline">\(\boldsymbol{\mu}\)</span> and TP matrix <span class="math inline">\(P\)</span> is the distribution vector <span class="math display">\[\lambda:=\lim_{n\to\infty}\mu\cdot P^n.\]</span></p>
</blockquote>
<p>This is often a challenging limit to find analytically and even numerically often requires Monte-Carlo simulations.</p>
<p><em> <strong>Example:</strong> Reconsider our last MC example with transition diagram given in the figure below.</em></p><em>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/complicated-transition-graph.png" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>Complicated transition diagram.</figcaption>
</figure>
</div>
<p>We know that the <span class="math inline">\(S_2:=\{1,2,3,4\}\)</span> is transient and so given enough time to run, the chain will either end on in <span class="math inline">\(S_1=\{5\}\)</span> or <span class="math inline">\(S_3=\{6,7\}\)</span>. We therefore need to ask the following questions:</p>
<ol type="1">
<li>How do we know what proportion of the time the chain ends in each class.</li>
<li>If the chain ends up in closed irreducible <span class="math inline">\(S_3\)</span>, what is the behavior of the state distribution in the limit? <span class="math inline">\(\rightarrow\)</span> <mark><em>Stationary Distributions</em></mark></li>
</ol>
</em><p><em></em></p>
</section>
<section id="stationary-distribution" class="level3">
<h3 class="anchored" data-anchor-id="stationary-distribution">Stationary Distribution</h3>
<p>A process is <mark><strong>strictly stationary</strong></mark> if its distribution does not change under translations, i.e.&nbsp;over time. More formally we give the following definition.</p>
<blockquote class="blockquote">
<p><strong>Definition: (<mark>Strictly Stationary Process</mark>)</strong><br>
A process <span class="math inline">\(\{ X_{n},~n\geq 0 \}\)</span> is <em>strictly stationary</em> if for any integers <span class="math inline">\(m\geq 0\)</span> and <span class="math inline">\(k&gt;0\)</span>, we have <span class="math display">\[(Y_{0}, Y_{1}, \dots Y_{m})\stackrel{\mathcal{D}}{=}(Y_{k}, Y_{k+1}, \dots, Y_{k+m})\]</span> that is, the distribution does not change under translations.</p>
</blockquote>
<p>This is often a challenging condition to show and so we also define a <mark><strong>weak stationarity</strong></mark> of the mean and covariance being invariant to changes in time. See oour discussion of Time Series Anaysis for more detailed noted on stationarity.</p>
<blockquote class="blockquote">
<p><strong>Definition: (<mark>Stationary Distribution</mark>)</strong><br>
The vector <span class="math inline">\(\pi=(\pi_{j},~j \in S)\)</span> is called a <em>stationary distribution</em> of a Markov chain if:</p>
<ol type="1">
<li><span class="math inline">\(\pi_{j}\geq 0\)</span>.</li>
<li><span class="math inline">\(\sum_{j\in S}\pi_{j}=1\)</span>.</li>
<li><span class="math inline">\(\pi=\pi P\)</span>.</li>
</ol>
</blockquote>
<p>Note that (3) can equivalently be written as <span class="math display">\[
\pi_{j}=\sum_{i \in S}\pi_{i}p_{i,j}\text{ for all }j \in S.
\]</span></p>
<p>Also note that <span class="math inline">\(\pi P^2=\pi P\cdot P=\pi P=\pi\)</span> and similarly, for all <span class="math inline">\(n&gt;1\)</span>, <span class="math inline">\(\pi P^n=\pi\)</span>, that is <span class="math inline">\(\pi_{j}=\sum_{i\in S}\pi_{i}p_{i,j}(n)\)</span> for all <span class="math inline">\(j \in S\)</span>.</p>
<blockquote class="blockquote">
<p><strong>Theorem: (Stationary Distribution)</strong> For any irreducible MC <span class="math inline">\(\{X\}\)</span> with a finite state space <span class="math inline">\(\mathcal{X}\)</span> there exists a stationary distribiton <span class="math inline">\(\pi\)</span>.</p>
</blockquote>
<p><em>Proof:</em></p>
<p>Let <span class="math inline">\(P\)</span> be the transition matrix on a finite state space <span class="math inline">\(\mathcal{X}\)</span>, and assume the chain is irreducible. In a finite Markov chain, at least one state is recurrent (otherwise all states would be transient, which is impossible in a finite state space because probability mass would have to “escape” forever without accumulating anywhere). Since the chain is irreducible, all states communicate with that recurrent state, hence every state is recurrent.</p>
<p>Because the chain is finite and irreducible, starting from any state <span class="math inline">\(i\)</span>, every other state <span class="math inline">\(j\)</span> is hit with positive probability in at most <span class="math inline">\(|S|-1\)</span> steps along some path. In particular, there exists an <span class="math inline">\(m\ge 1\)</span> with <span class="math display">\[
p^{(m)}_{ii} &gt; 0.
\]</span></p>
<p>Let <span class="math inline">\(\tau_i^+ = \inf\{n\ge1: X_n=i\}\)</span> be the first return time to <span class="math inline">\(i\)</span>. Then each block of <span class="math inline">\(m\)</span> steps has probability at least <span class="math inline">\(p^{(m)}_{ii}\)</span> of containing a return to <span class="math inline">\(i\)</span> at its endpoint, so <span class="math display">\[
\mathbb{P}_i(\tau_i^+ &gt; km) \le (1-p^{(m)}_{ii})^k.
\]</span></p>
<p>Hence the tail of <span class="math inline">\(\tau_i^+\)</span> is geometrically bounded, implying <span class="math display">\[
\mathbb{E}_i[\tau_i^+] &lt; \infty.
\]</span></p>
<p>So the chain is positive recurrent. Define, for each <span class="math inline">\(j\in S\)</span>, <span class="math display">\[
\pi_j := \frac{\mathbb{E}_i\!\left[\sum_{n=0}^{\tau_i^+-1}\mathbf{1}\{X_n=j\}\right]}{\mathbb{E}_i[\tau_i^+]}.
\]</span></p>
<p>This is the expected fraction of time spent in state <span class="math inline">\(j\)</span> during an <span class="math inline">\(i\to i\)</span> regeneration cycle. Clearly <span class="math inline">\(\pi_j\ge 0\)</span> and <span class="math display">\[
\sum_{j\in S}\pi_j
= \frac{\mathbb{E}_i\!\left[\sum_{n=0}^{\tau_i^+-1}\sum_{j\in S}\mathbf{1}\{X_n=j\}\right]}{\mathbb{E}_i[\tau_i^+]}
= \frac{\mathbb{E}_i[\tau_i^+]}{\mathbb{E}_i[\tau_i^+]}=1,
\]</span></p>
<p>so <span class="math inline">\(\pi\)</span> is a probability distribution. To show <span class="math inline">\(\pi P=\pi\)</span>, note that the expected number of visits to <span class="math inline">\(j\)</span> during a cycle equals the expected number of transitions <em>into</em> <span class="math inline">\(j\)</span> during the cycle (up to the regeneration boundary, which contributes no net imbalance because the cycle starts and ends at <span class="math inline">\(i\)</span>). Formally, by the Markov property and counting transitions within the cycle, <span class="math display">\[
\mathbb{E}_i\!\left[\sum_{n=0}^{\tau_i^+-1}\mathbf{1}\{X_{n+1}=j\}\right]
= \sum_{k\in S}\mathbb{E}_i\!\left[\sum_{n=0}^{\tau_i^+-1}\mathbf{1}\{X_n=k\}\right]p_{kj}.
\]</span></p>
<p>Divide both sides by <span class="math inline">\(\mathbb{E}_i[\tau_i^+]\)</span> to get <span class="math display">\[
\pi_j = \sum_{k\in S}\pi_k p_{kj},
\]</span></p>
<p>which is exactly <span class="math inline">\(\pi P=\pi\)</span>. Thus a stationary distribution exists.<br>
<span class="math inline">\(\square\)</span></p>
<p><em><strong>Example:</strong> Consider a Markov chain describing the meals served by a restaurant with transition graph shown below in Figure 1 provided by helpful video on Markov chains by <a href="https://www.youtube.com/watch?v=i3AkTO9HLXo&amp;t=110s">Normalized Nerd</a>.</em></p><em>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/food_example.png" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>Example transition diagram for a MC describing meals served at a restaurant.</figcaption>
</figure>
</div>
<p>Taking state 1 to be hamburger, state 2 to be pizza and state 3 to be hotdog, the transition matrix <span class="math inline">\(P\)</span> can be written as <span class="math display">\[
P=\begin{bmatrix}
0.2 &amp; 0.6 &amp; 0.2  \\
0.3 &amp; 0 &amp; 0.7  \\
0.5 &amp; 0 &amp; 0.5
\end{bmatrix}.
\]</span></p>
<p>Given the restaurant first serves pizza we can define the initial distribution <span class="math inline">\(\pi_{0}=\begin{bmatrix}0 &amp; 1 &amp; 0\end{bmatrix}\)</span>. Applying the transition matrix <span class="math inline">\(P\)</span> we get <span class="math display">\[
\pi_{0}P=\begin{bmatrix}
0 &amp; 1 &amp; 0
\end{bmatrix}\cdot \begin{bmatrix}
0.2 &amp; 0.6 &amp; 0.2  \\
0.3 &amp; 0 &amp; 0.7  \\
0.5 &amp; 0 &amp; 0.5
\end{bmatrix}=\begin{bmatrix}
0.3 &amp; 0 &amp; 0.7
\end{bmatrix}=\pi_{1},
\]</span></p>
<p>the second state future transition probabilities. Repeating this step for <span class="math inline">\(\pi_{1}\)</span> we have <span class="math display">\[
\pi_{0}P=\begin{bmatrix}
0.3 &amp; 0 &amp; 0.7
\end{bmatrix}\cdot \begin{bmatrix}
0.2 &amp; 0.6 &amp; 0.2  \\
0.3 &amp; 0 &amp; 0.7  \\
0.5 &amp; 0 &amp; 0.5
\end{bmatrix}=\begin{bmatrix}
0.41 &amp; 0.18 &amp; 0.41
\end{bmatrix}=\pi_{2},
\]</span></p>
<p>If a stationary distribution <span class="math inline">\(\pi\)</span> exists it would mean that as <span class="math inline">\(\pi_{0}, \pi_{1}, \dots\)</span> continues, eventually it will reach a point where it doesn’t change when <span class="math inline">\(P\)</span> is applied, hence using linear algebra we can write the expression <span class="math display">\[
\pi P=\pi,
\]</span></p>
<p>see Definition 2 above. Additionally, since <span class="math inline">\(\pi\)</span> is a vector of probabilities we have that <span class="math inline">\(\pi(1)+\pi(2)+\pi(3)=1\)</span> and solving this system gives the stationary distribution <span class="math display">\[
\pi=\begin{bmatrix}
\frac{25}{71} &amp; \frac{15}{71} &amp; \frac{31}{71}
\end{bmatrix}.
\]</span></p>
</em><p><em>We can numerically confirm our result by iteratively applying the transition probability matrix: </em></p>
<div id="777e96f5" class="cell" data-fig-height="6" data-fig-width="12" data-execution_count="4">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>P <span class="op">=</span> np.array([</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">.2</span>, <span class="fl">.6</span>, <span class="fl">.2</span>],</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">.3</span>, <span class="dv">0</span>, <span class="fl">.7</span>],</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">.5</span>, <span class="dv">0</span>, <span class="fl">.5</span>]</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>pi <span class="op">=</span> np.array([</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>pi_list <span class="op">=</span> []</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>pi_list.append(pi)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    pi <span class="op">=</span> pi <span class="op">@</span> P</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    pi_list.append(pi) </span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>pi_list <span class="op">=</span> np.array(pi_list).squeeze()</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>ax.plot(<span class="bu">range</span>(n<span class="op">+</span><span class="dv">1</span>), pi_list[:,<span class="dv">0</span>], color<span class="op">=</span><span class="st">"red"</span>, label<span class="op">=</span><span class="st">"Hamburger"</span>)</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>ax.plot(<span class="bu">range</span>(n<span class="op">+</span><span class="dv">1</span>), pi_list[:,<span class="dv">1</span>], color<span class="op">=</span><span class="st">"green"</span>, label<span class="op">=</span><span class="st">"Pizza"</span>)</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>ax.plot(<span class="bu">range</span>(n<span class="op">+</span><span class="dv">1</span>), pi_list[:,<span class="dv">2</span>], color<span class="op">=</span><span class="st">"blue"</span>, label<span class="op">=</span><span class="st">"Hotdog"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="index_files/figure-html/cell-5-output-1.png" width="571" height="411" class="figure-img"></p>
<figcaption>Transition probability convergence plot.</figcaption>
</figure>
</div>
</div>
</div>
<p><strong>Definition: (<mark>Doubly Stochastic Matrices</mark>)</strong><br>
A matrix <span class="math inline">\(P:=(p_{i,j})_{i,j\in\mathcal{S}}\)</span> is said to be doubly stochastic when both rows and columns sum to 1, that is <span class="math display">\[
\sum_{j\in\mathcal{X}}p_{i,j} = \sum_{i\in\mathcal{X}}p_{i,j}=1.
\]</span></p>
<p><strong>Theorem: (<mark>Uniform Stationary Distributions for Doubly Stochastic MCs</mark>)</strong><br>
A finite state homogenous MC with doubly stochastic transition probability matrix has a uniform stationary distribution.</p>
<p><em>Proof</em><br>
Assume <span class="math inline">\(\mathcal{X}\)</span> has <span class="math inline">\(n\)</span> elements and define <span class="math inline">\(\pi = (\pi_i)_{i\in\mathcal{X}}\)</span> where <span class="math inline">\(\pi_i=1/n\)</span>. Then clearly</p>
<p><span class="math display">\[
\sum_{i\in\mathcal{X}} \pi_i p_{i,j} = \frac{1}{n}\sum_{i\in\mathcal{X}}p_{i,j} = \frac{1}{n} = \pi_j,
\]</span></p>
<p>holds for all <span class="math inline">\(j\in\mathcal{X}\)</span>. Since by definition <span class="math inline">\(\pi\)</span> is normalized we obtain the result.<br>
<span class="math inline">\(\square\)</span></p>


</section>
</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/johnrobininston\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright 2026, John Inston.</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>