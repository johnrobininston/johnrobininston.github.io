{
  "hash": "70bd4366e75662c7fd35442293c236b3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: R Basics II - Atomic Data Structures\nauthor: John Robin Inston\ndate: \"2025-03-23\"\ncategories: [Data Science with R]\ndate-modified: \"2025-05-30\"\ntoc: true\n---\n\n\n\nThis post contains notes for Chapter 3 of my course series [Data Science with R](/courses/intro_to_data_science/index.qmd) covering atomic data structures.  Specifically, we discuss scalars, vectors and matrices, how to construct them, manipulate them, and perform computations with them.  For efficiency I avoid discussion of the underlying mathematics of vector and matrix computations and direct any interested readers towards my course and relevant notes on [Linear Algebra](/courses/linear_algebra/index.qmd).\n\n## Scalars\n\nA **scalar** data form is an object holding one value.  For example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 16\ny <- \"scalar\"\nz <- FALSE\n```\n:::\n\n\n\nWe often need to use different data structures that contain multiple values of different dimensions of different data types.  `R` can handle data types including: (1) **Vectors**; (2) **Matrices**; (3) **Dataframes**; and (4) **Lists**.  In this note we will cover the atomic data types of vectors and matrices, specifically how we define them and how we perform computations with them.\n\n## Vectors\n\nA **vector** data form is an object holding multiple values of the **same datatype**, i.e. all numeric or all strings.  We call objects with this property **atomic**.\n\nThere are multiple functions for constructing vectors in `R` including `c()`, `seq()`, `:`, and `rep()`.\n\n### `c()` Function\n\nThe simplest way to define a vector in `R` is using the `c()` function where you can specify each element of the vector within the parenthesis:\n\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\n# Numeric vector\nnum_vec <- c(4,1,6,8,4,2,5)\nnum_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 1 6 8 4 2 5\n```\n\n\n:::\n\n```{.r .cell-code}\n# Character string vector\nchar_vec <- c(\"dog\", \"cat\", \"goose\", \"monkey\", \"elephant\")\nchar_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"dog\"      \"cat\"      \"goose\"    \"monkey\"   \"elephant\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Boolean vector\nbool_vec <- c(\"TRUE\", \"FALSE\", \"FALSE\", \"FALSE\", \"TRUE\")\nbool_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"TRUE\"  \"FALSE\" \"FALSE\" \"FALSE\" \"TRUE\" \n```\n\n\n:::\n:::\n\n\n\n### `rep()` Function\n\nThe `rep()` function is a simple way to construct vectors where a single value is repeated.  The arguments for the function `rep(x, times)` where `x` specifies the scalar / vector you with to repeat and `times` specifies the number of times you want it repeated:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# rep() function\nrep(x = 7, times = 14)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 7 7 7 7 7 7 7 7 7 7 7 7 7 7\n```\n\n\n:::\n:::\n\n\n\n### `seq()` Function\n\nThe `seq()` function is used specifically to construct numeric sequences.  The syntax for `seq(from, to, by, length.out)` has arguments: (1) `from` specifying the starting values; (2) `to` specifying the final value; (3) `by` specifying the step size; and (4) `length.out` specifying the length of the resulting vector.  Note that we cannot include arguments (3) and (4) at the same time!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# seq() function with by\nseq(from = 1, to = 10, by = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 3 5 7 9\n```\n\n\n:::\n\n```{.r .cell-code}\n# seq() function with length.out\nseq(from = 1, to = 10, length.out = 9)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.000  2.125  3.250  4.375  5.500  6.625  7.750  8.875 10.000\n```\n\n\n:::\n:::\n\n\n\nA quick alternative if we wish to make a vector of increasing integers is simply to use the `:` syntax:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# integers from -3 to 4\n-3:4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -3 -2 -1  0  1  2  3  4\n```\n\n\n:::\n:::\n\n\n\n### Combining Methods\n\nAny of these functions can be nested within one another to produce more complicated vectors.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# c() with seq() and rep()\nc(\n    rep(4, 5),\n    seq(0, 10, by = 1)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  4  4  4  4  4  0  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n\n::: {.callout-tip}\n\n## Exercise 1\n\nUse any combinations of the above functions to reproduce the following vectors and save them to the corresponding objects.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1.00 1.25 1.50 1.75 2.00 1.00 9.00 1.00 9.00 1.00 9.00\n```\n\n\n:::\n\n```{.r .cell-code}\nt\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1 2 3 4 4 3 2 1 0 0\n```\n\n\n:::\n:::\n\n\n\n:::\n\n### Important Vector Functions\n\nWhen working with vectors we will often use several key base functions to ascertain important properties and manipulate vector objects.  The first of these key functions is `length()` which returns the number of elements of a vector:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(num_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n\n\nNext, it is often useful to know what datatype the vector contains, something that we can determine with the `typeof()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# confirm the data type of the character strring vector\ntypeof(char_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\nFinally, we often wish to sort vectors into some kind of order (e.g. alphabetical, decreasing).  To accomplish this we can use the `sort()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# sort numerical vector in increasing order\nsort(num_vec, decreasing = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 4 4 5 6 8\n```\n\n\n:::\n:::\n\n\n\nNote that here we have specified `decreasing = FALSE` in the function.  This is what is known as an **argument** and they are what allow to control more sophisticated functions.  With any function we can see details of what arguments we can specify by using the `help()` or `?` functions.\n\n### Vector Indexing\n\nNow suppose we wish to retrieve only specific elements of a vector.  We do so by **indexing** whereby we select which elements to return inside braces `[]`.  To return specific elements we simply note the numerical index of the element (i.e. 3 for the third element):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# return the 3rd element of the boolean vector\nbool_vec[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"FALSE\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# return the 3rd, 4th and 5th element of the numerical vector\nnum_vec[c(3,4,5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6 8 4\n```\n\n\n:::\n:::\n\n\n\nNote above that to return multiple elements we need to specify our index as a vector.  To return every element besides specific elements we use **negative indices**:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# return everything but the 3rd element of the boolean vector\nbool_vec[-3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"TRUE\"  \"FALSE\" \"FALSE\" \"TRUE\" \n```\n\n\n:::\n\n```{.r .cell-code}\n# return everything but the 3rd, 4th and 5th element of the numerical vector\nnum_vec[-c(3,4,5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 1 2 5\n```\n\n\n:::\n:::\n\n\n\n### Vector Filtering\n\nWe can also index vectors using logical statements, that is return elements of a vector that satisfy some logical condition, through a process known as **filtering**:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# filter the numerical vector to return only numbers greater than or equal to 4\nnum_vec[num_vec >= 4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 6 8 4 5\n```\n\n\n:::\n:::\n\n\n\n### Vector Computations\n\nOne of the strengths of `R` as a programming language is its efficiency with performing **vector computations**.  There are a variety of vector computations we can perform, starting with muliplication by a scalar which is applied element-wise:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# vector times a scalar\n2 * c(1,2,3,4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4 6 8\n```\n\n\n:::\n:::\n\n\n\nWe can also add a scalar and a vector which is also applied element-wise:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 + c(1,2,3,4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4 5 6\n```\n\n\n:::\n:::\n\n\n\nIf we wish to add or multiply two vectors we must ensure they are of the **same length**:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# add two vectors\nc(1,2,3) + c(10,12,14)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 14 17\n```\n\n\n:::\n\n```{.r .cell-code}\n# multiply two vectors\nc(1,2,3) * c(10,12,14)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 24 42\n```\n\n\n:::\n:::\n\n\n\n### Recycling\n\nYou might ask yourself what happens if we add together two vectors of different lengths?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1,2) + c(10,20,30,40)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 22 31 42\n```\n\n\n:::\n:::\n\n\n\nFrom this example you might have discerned that `R` did not return an `error` message but instead **recycled** values of the smaller vector (looping from start to finish) to perform the computation.\n\n### Coercion\n\n**Vector coercion** is when R changes the data type in a vector when it is presented with a situation when you are trying to combine different data types.  The default order of priority taken by `R` is:\n\n1. Character Strings;\n2. Numeric; and\n3. Boolean.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Coercion from boolean to numeric\nc(TRUE, FALSE, 1,2,3,1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 0 1 2 3 1\n```\n\n\n:::\n\n```{.r .cell-code}\n# Coercion from boolen and numeric to character strings\nc(\"Dog\", TRUE, TRUE, 5, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Dog\"  \"TRUE\" \"TRUE\" \"5\"    \"10\"  \n```\n\n\n:::\n:::\n\n\n\n## Matrices\n\nMatrices are essentially 2 dimensional vectors and so again the mathematics of matrix computations is given by Linear Algebra. For example, we define a matrix $A$ with $4$ columns and $3$ rows  by\n\n$$\nA := \\begin{bmatrix}\na_{1,1} & a_{1,2} & a_{1,3} \\\\\na_{2,1} & a_{2,2} & a_{2,3} \\\\\na_{3,1} & a_{3,2} & a_{3,3} \\\\\na_{4,1} & a_{4,2} & a_{4,3} \n\\end{bmatrix},\n$$\n\nwhere $a_{i,j}\\in\\mathbb{R}$ for all $i,j$.  We can see that vectors are simply a specific kind of matrix, i.e. a matrix with only one column.  \n\n### Constructing Matrices\n\nThere are three functions we use to construct matrices:\n\n- `matrix()`;\n- `rbind()`;\n- `cbind()`.\n\n#### `matrix()`\n\nThe simplest syntax for the `matrix()` function is:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# matrix() syntax\nmatrix(data = NA, nrow = n, ncol = m, byrow = FALSE)\n```\n:::\n\n\n\nwhere:\n\n- `data` - is a vector of the matrix elements;\n- `nrow` - specifies the number of rows of the matrix;\n- `ncol` - specifies the number of columns of the matrix;\n- `byrow` - is a boolean specifying if the matrix should be built row-wise.\n\nFor an example, suppose we wish to construct a 4x4 matrix consisting of the integers from 1 to 16 constructed row-wise.  Written mathematically, we wish to construct\n$$\nA := \\begin{bmatrix}\n1 & 2 & 3 & 4 \\\\\n5 & 6 & 7 & 8 \\\\\n9 & 10 & 11 & 12 \\\\\n13 & 14 & 15 & 16\n\\end{bmatrix}.\n$$\n\nTo construct this matrix in `R` we can write:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# matrix() function\nA <- matrix(1:16, nrow = 4, ncol = 4, byrow = TRUE)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\n```\n\n\n:::\n:::\n\n\n\n#### `rbind()` and `cbind()`\n\nSometimes we might have several vectors that we with to combine into a matrix.  To combine vectors row-wise we use `rbind()` and to combine vectors column-wise we use `cbind()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# rbind() function\nrbind(1:4, 5:8, 9:12, 13:16)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\n```\n\n\n:::\n\n```{.r .cell-code}\ncbind(1:4, 5:8, 9:12, 13:16)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\n```\n\n\n:::\n:::\n\n\n\n### Matrix Computations\n\nAtomic data structures are not flexible but this rigid structure allows them to be easily manipulated.  The mathematical background for arithmetic with matrices is studied in Linear Algebra.  \n\nWe can add to matrices together if they have the same number of columns and rows (just rows for vectors) in which case we say the matrices have the same **dimension**.  In this case, the sum of two matrices is simply computed element-wise.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nB <- matrix(\n    seq(from=2, length.out=16, by=2), \n    nrow = 4, ncol = 4, byrow = TRUE\n    )\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    2    4    6    8\n[2,]   10   12   14   16\n[3,]   18   20   22   24\n[4,]   26   28   30   32\n```\n\n\n:::\n\n```{.r .cell-code}\nA + B\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    3    6    9   12\n[2,]   15   18   21   24\n[3,]   27   30   33   36\n[4,]   39   42   45   48\n```\n\n\n:::\n:::\n\n\n\nSimilarly, scalar multiplication is computed element-wise.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n7 * A\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    7   14   21   28\n[2,]   35   42   49   56\n[3,]   63   70   77   84\n[4,]   91   98  105  112\n```\n\n\n:::\n:::\n\n\n\nWhen computing the cross-product of matrices $A\\times B$ we require that the number of rows of $A$ is equal to the number of columns of $B$.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA * B\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    2    8   18   32\n[2,]   50   72   98  128\n[3,]  162  200  242  288\n[4,]  338  392  450  512\n```\n\n\n:::\n\n```{.r .cell-code}\nB * c(1,2,3)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in B * c(1, 2, 3): longer object length is not a multiple of shorter\nobject length\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    2    8   18    8\n[2,]   20   36   14   32\n[3,]   54   20   44   72\n[4,]   26   56   90   32\n```\n\n\n:::\n\n```{.r .cell-code}\nB * c(1,2,3,4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    2    4    6    8\n[2,]   20   24   28   32\n[3,]   54   60   66   72\n[4,]  104  112  120  128\n```\n\n\n:::\n:::\n\n\n\n### Matrix Indexing\n\nWhen we wish to retrieve a specific element or elements of a data structure we need to perform indexing which in `R`.  Considering the matrix $A$ we defined earlier.  If we wished to select the 5th element of the matrix we can use the brace `[]` syntax and write:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA[5]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\nNow, supposing we wished to select from the 2nd to the 8th element of the matrix, we can use the same syntax but this time specifying a vector of the index values in the braces:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA[2:8]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  5  9 13  2  6 10 14\n```\n\n\n:::\n:::\n\n\n\nOften we might be more interested in selecting specific rows or columns of the matrix.  To select a column we use the same syntax but this time with a comma `A[i,j]` where `i` specifies the row number of `j` specifies the column number.  If we with to select the entire row we simply leave the value of `j` blank and vice versa:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1st row\nA[1,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\n# 4th column\nA[,4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  4  8 12 16\n```\n\n\n:::\n:::\n\n\n\nWe can select multiple rows / columns by using the same syntax as before and including a vector of the row / column index values you with to select:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2nd and 3rd rows\nB[2:3, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]   10   12   14   16\n[2,]   18   20   22   24\n```\n\n\n:::\n\n```{.r .cell-code}\n# 2nd and 3rd rows + 1st and 4th columns\nA[2:3, c(1,4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    5    8\n[2,]    9   12\n```\n\n\n:::\n:::\n\n\n\nWe can also chain index whereby we immediately index the output of our indexing:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA[2:3, c(1,4)][2:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9 8\n```\n\n\n:::\n:::\n\n\n\n### Matrix Filtering\n\nNow suppose we wish to only select elements of a matrix that specify a certain logical condition.  We can again index but this time instead of specifying the index numbers we specify the condition we wish to be satisfied:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA[A > 10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 13 14 11 15 12 16\n```\n\n\n:::\n:::\n\n\n\nThis is particularly helpful when we wish to edit our original matrix.  For example, if we wish to change $A$ such that all elements $\\leq 10$ are set to zero we could write:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA_new <- A\nA_new[A_new < 10] <- 0\nA_new\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    0    0    0    0\n[2,]    0    0    0    0\n[3,]    0   10   11   12\n[4,]   13   14   15   16\n```\n\n\n:::\n:::\n\n\n\n### Matrix Functions\n\nThere are also a collection of preloaded functions for performing computations and handling vectors and matrices such as:\n\n- `dim()` - returns the dimensions of a matrix (i.e. number of rows and columns);\n- `det()` - computes the determinant of a matrix;\n- `solve()` - computes the inverse of a matrix.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# return the dimensions of A\ndim(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 4\n```\n\n\n:::\n\n```{.r .cell-code}\n# compute the determinant of A\ndet(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.733165e-30\n```\n\n\n:::\n:::\n\n\n\nFor more information on matrix determinants and inverses please see my course notes on [Linear Algebra](/courses/linear_algebra/index.qmd)\n\n\n\n\n<div style=\"display: flex; justify-content: space-between; padding: 20px 0;\">\n  <!-- Back Button -->\n  <a href=\"/posts/rds2-basics1-operators/index.qmd\" style=\"text-decoration: none; font-size: 18px;\">\n    &#8592; Previous Chapter\n  </a>\n  \n  <!-- Forward Button -->\n  <a href=\"/posts/rds4-basics3-dataframes/index.qmd\" style=\"text-decoration: none; font-size: 18px;\">\n    Next Chapter &#8594;\n  </a>\n</div>",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}