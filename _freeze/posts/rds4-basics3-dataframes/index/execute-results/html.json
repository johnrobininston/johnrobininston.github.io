{
  "hash": "6740d2ef2450332d7d65e33d0ad2b976",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: R Basics III - Dataframes and Lists\nauthor: John Robin Inston\ndate: \"2025-03-24\"\ndate-modified: \"2025-06-01\"\ncategories: [Data Science with R]\ntoc: true\n---\n\n\n\nThis post contains notes for Chapter 4 of my course series [Data Science with R](/courses/intro_to_data_science/index.qmd) covering dataframes and lists.  Specifically we will look at `R`'s base functionality for dataframes and lists including how to construct and manipulate these objects.  We note that although it is preferable to manipulate dataframes using the `tidyverse` package (something we cover in a future lesson) this note focusses first on detailing the base functionality.\n\n\n\n::: {.cell}\n\n:::\n\n\n\n## Non-Atomic Data Structures\n\nSo far we have introduced a variety of atomic data structures (e.g. scalars, vectors, matrices and arrays) each of which are designed for ease of computation and interaction by being restricted to containing only one datatype.  However, as any scientist who has ever collected data will tell you, we often need to define objects that contain multiple datatypes, namely:\n\n1. **Dataframes**; and\n2. **Lists**.\n\nBy containing multiple datatypes you sacrifice computationally tractability but gain immense flexibility for data storage.\n\n## Dataframes\n\nIn `R` a dataframe can be intuitively pictured as a table of data where each column is of the same datatype.  For example here is a table showing the first 6 rows of the pre-loaded dataframe `iris` which contains 4 numeric columns and one factor column:\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n| Sepal.Length| Sepal.Width| Petal.Length| Petal.Width|Species |\n|------------:|-----------:|------------:|-----------:|:-------|\n|          5.1|         3.5|          1.4|         0.2|setosa  |\n|          4.9|         3.0|          1.4|         0.2|setosa  |\n|          4.7|         3.2|          1.3|         0.2|setosa  |\n|          4.6|         3.1|          1.5|         0.2|setosa  |\n|          5.0|         3.6|          1.4|         0.2|setosa  |\n|          5.4|         3.9|          1.7|         0.4|setosa  |\n\n\n:::\n:::\n\n\n\n### Constructing Dataframes\n\nTo construct a dataframe in `R` we can use the `dataframe()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(..., row.names = NULL, check.rows = FALSE,\n           check.names = TRUE, fix.empty.names = TRUE,\n           stringsAsFactors = FALSE)\n```\n:::\n\n\n\nThis function has multiple arguments but the most important are `...`, `row.names` and `stringsAsFactors`.  Lets go through a few examples of constructing data frames to build up our understanding. \n\nLets start by building a dataframe with three columns, the first containing numbers, the second containing boolean objects and the third containing character strings.  To do so we specify each columns values in a vector ensuring all three vectors are of the same length to avoid an `error` message:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data.frame(\n    c(1,2,3),\n    c(TRUE, TRUE, FALSE),\n    c(\"alpha\", \"beta\", \"gamma\")\n)\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  c.1..2..3. c.TRUE..TRUE..FALSE. c..alpha....beta....gamma..\n1          1                 TRUE                       alpha\n2          2                 TRUE                        beta\n3          3                FALSE                       gamma\n```\n\n\n:::\n:::\n\n\n\nLooking at our print out we note othat we have successfully created a dataframe with: \n\n- Numbered rows from 1 to 3; and\n- Generated column names based on the vector inputs.\n\nWe can specify the names of the columns of the dataframe by slightly tweaking our code:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data.frame(\n    numbers = c(1,2,3),\n    booleans = c(TRUE, TRUE, FALSE),\n    strings = c(\"alpha\", \"beta\", \"gamma\")\n)\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  numbers booleans strings\n1       1     TRUE   alpha\n2       2     TRUE    beta\n3       3    FALSE   gamma\n```\n\n\n:::\n:::\n\n\n\nWhat if we want to name the rows?  In this case we can use the `row.names` argument as\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data.frame(\n    numbers = c(1,2,3),\n    booleans = c(TRUE, TRUE, FALSE),\n    strings = c(\"alpha\", \"beta\", \"gamma\"),\n    row.names = c(\"first\", \"second\", \"third\")\n)\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       numbers booleans strings\nfirst        1     TRUE   alpha\nsecond       2     TRUE    beta\nthird        3    FALSE   gamma\n```\n\n\n:::\n:::\n\n\n\nFinally, we can use the `stringsAsFactors` argument to specify that we wish to convert the `strings` column into a `factor` column:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data.frame(\n    numbers = c(1,2,3),\n    booleans = c(TRUE, TRUE, FALSE),\n    strings = c(\"alpha\", \"beta\", \"gamma\"),\n    row.names = c(\"first\", \"second\", \"third\"),\n    stringsAsFactors = TRUE\n)\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       numbers booleans strings\nfirst        1     TRUE   alpha\nsecond       2     TRUE    beta\nthird        3    FALSE   gamma\n```\n\n\n:::\n:::\n\n\n\nThis does not change the dataframe visually but if we will see in the following section that it has changed the datatype of the `strings` column.\n\n### Indexing Dataframes\n\nDataframe indexing behaves a lot like matrix indexing as discussed in [R Basics II (Atomic Data Structures)](/posts/rds3-basics2-atomicdata/index.qmd).  We can use **numerical indexing** with dataframes by specifying the row $i$ and column number $j$ of the elements we wish to return inside braces `[]`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# return the element in the 2nd row and 3rd column\ndata[2,3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] beta\nLevels: alpha beta gamma\n```\n\n\n:::\n\n```{.r .cell-code}\n# return column 2\ndata[,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n#Â return the second and third row for both columns 1 and 3\ndata[2:3, c(1,3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       numbers strings\nsecond       2    beta\nthird        3   gamma\n```\n\n\n:::\n:::\n\n\n\nAlternatively, we can specify the name of the column and rows using quotation marks `' '`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# return the numbers column\ndata[\"numbers\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       numbers\nfirst        1\nsecond       2\nthird        3\n```\n\n\n:::\n\n```{.r .cell-code}\n# return the numbers column for the second row\ndata[\"second\", \"numbers\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\nA quick syntax for returning a specific column is `$`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# select the boolean column\ndata$booleans\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\nAs with atomic data structures we can also filter values using logical statements but it is important to consider the datatypes being considered:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# return the rows that have numbers == 2\ndata[data$numbers == 2,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       numbers booleans strings\nsecond       2     TRUE    beta\n```\n\n\n:::\n\n```{.r .cell-code}\n# return the rows that have numbers == 1 or boolean == TRUE\ndata[data$numbers == 2 | data$booleans == TRUE,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       numbers booleans strings\nfirst        1     TRUE   alpha\nsecond       2     TRUE    beta\n```\n\n\n:::\n:::\n\n\n\n## Lists\n\nLists are the most flexible data storage tool, allowing us to store scalars, matrices, arrays, dataframes or even other lists by some indexing or naming convention.  We have already created a dataframe object `data` and in previous posts we used the following code to create scalars, vectors and matrices:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- \"scalar\"\nchar_vec <- c(\"dog\", \"cat\", \"goose\", \"monkey\", \"elephant\")\nB <- matrix(\n    seq(from=2, length.out=16, by=2), \n    nrow = 4, ncol = 4, byrow = TRUE\n    )\n```\n:::\n\n\n\nTo create a list of these objects called `object_list` we naturally use the `list()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobject_list <- list(\n    scalar = y,\n    vector = char_vec,\n    matrix = B,\n    dataframe = data\n)\n```\n:::\n\n\n\nThis creates a list with 4 elements which we can access using **double braces** `[[]]`, either using the specified name or the corresponding numerical index:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# return the vector from the list\nobject_list[[\"vector\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"dog\"      \"cat\"      \"goose\"    \"monkey\"   \"elephant\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# return the third element from the list (the matrix)\nobject_list[[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    2    4    6    8\n[2,]   10   12   14   16\n[3,]   18   20   22   24\n[4,]   26   28   30   32\n```\n\n\n:::\n:::\n\n\n\nWe typically only use lists for convenient data storage due to their restrictive structure making any computations impossible.  \n\n<div style=\"display: flex; justify-content: space-between; padding: 20px 0;\">\n  <!-- Back Button -->\n  <a href=\"/posts/rds3-basics2-atomicdata/index.qmd\" style=\"text-decoration: none; font-size: 18px;\">\n    &#8592; Previous Chapter\n  </a>\n  \n  <!-- Forward Button -->\n  <a href=\"/posts/rds5-probability-basics/index.qmd\" style=\"text-decoration: none; font-size: 18px;\">\n    Next Chapter &#8594;\n  </a>\n</div>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}