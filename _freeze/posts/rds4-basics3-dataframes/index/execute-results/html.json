{
  "hash": "40ce232f5289de537a9a10637803aac9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: R Basics III (Dataframes and Lists)\nauthor: John Robin Inston\ndate: \"2025-03-24\"\ndate-modified: \"2025-06-01\"\ncategories: [Data Science with R]\ntoc: true\n---\n\n\n\nThis post contains notes for Chapter 4 of my course series [Data Science with R](/courses/intro_to_data_science/index.qmd) covering dataframes and lists.  Specifically we will look at `R`'s base functionality for dataframes and lists including how to construct and manipulate these objects.  We note that although it is preferable to manipulate dataframes using the `tidyverse` package (something we cover in a future lesson) this note focusses first on detailing the base functionality.\n\n\n\n::: {.cell}\n\n:::\n\n\n\n## Non-Atomic Data Structures\n\nSo far we have introduced a variety of atomic data structures (e.g. scalars, vectors, matrices and arrays) each of which are designed for ease of computation and interaction by being restricted to containing only one datatype.  However, as any scientist who has ever collected data will tell you, we often need to define objects that contain multiple datatypes, namely:\n\n1. **Dataframes**; and\n2. **Lists**.\n\nBy containing multiple datatypes you sacrifice computationally tractability but gain immense flexibility for data storage.\n\n## Dataframes\n\nIn `R` a dataframe can be intuitively pictured as a table of data where each column is of the same datatype.  For example here is a table showing the first 6 rows of the pre-loaded dataframe `iris` which contains 4 numeric columns and one factor column:\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n| Sepal.Length| Sepal.Width| Petal.Length| Petal.Width|Species |\n|------------:|-----------:|------------:|-----------:|:-------|\n|          5.1|         3.5|          1.4|         0.2|setosa  |\n|          4.9|         3.0|          1.4|         0.2|setosa  |\n|          4.7|         3.2|          1.3|         0.2|setosa  |\n|          4.6|         3.1|          1.5|         0.2|setosa  |\n|          5.0|         3.6|          1.4|         0.2|setosa  |\n|          5.4|         3.9|          1.7|         0.4|setosa  |\n\n\n:::\n:::\n\n\n\n### Constructing Dataframes\n\nTo construct a dataframe in `R` we can use the `dataframe()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(..., row.names = NULL, check.rows = FALSE,\n           check.names = TRUE, fix.empty.names = TRUE,\n           stringsAsFactors = FALSE)\n```\n:::\n\n\n\nThis function has multiple arguments but the most important are `...`, `row.names` and `stringsAsFactors`.  Lets go through a few examples of constructing data frames to build up our understanding. \n\nLets start by building a dataframe with three columns, the first containing numbers, the second containing boolean objects and the third containing character strings.  To do so we specify each columns values in a vector ensuring all three vectors are of the same length to avoid an `error` message:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data.frame(\n    c(1,2,3),\n    c(TRUE, TRUE, FALSE),\n    c(\"alpha\", \"beta\", \"gamma\")\n)\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  c.1..2..3. c.TRUE..TRUE..FALSE. c..alpha....beta....gamma..\n1          1                 TRUE                       alpha\n2          2                 TRUE                        beta\n3          3                FALSE                       gamma\n```\n\n\n:::\n:::\n\n\n\nLooking at our print out we note othat we have successfully created a dataframe with: \n\n- Numbered rows from 1 to 3; and\n- Generated column names based on the vector inputs.\n\nWe can specify the names of the columns of the dataframe by slightly tweaking our code:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data.frame(\n    numbers = c(1,2,3),\n    booleans = c(TRUE, TRUE, FALSE),\n    strings = c(\"alpha\", \"beta\", \"gamma\")\n)\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  numbers booleans strings\n1       1     TRUE   alpha\n2       2     TRUE    beta\n3       3    FALSE   gamma\n```\n\n\n:::\n:::\n\n\n\nWhat if we want to name the rows?  In this case we can use the `row.names` argument as\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data.frame(\n    numbers = c(1,2,3),\n    booleans = c(TRUE, TRUE, FALSE),\n    strings = c(\"alpha\", \"beta\", \"gamma\"),\n    row.names = c(\"first\", \"second\", \"third\")\n)\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       numbers booleans strings\nfirst        1     TRUE   alpha\nsecond       2     TRUE    beta\nthird        3    FALSE   gamma\n```\n\n\n:::\n:::\n\n\n\nFinally, we can use the `stringsAsFactors` argument to specify that we wish to convert the `strings` column into a `factor` column:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data.frame(\n    numbers = c(1,2,3),\n    booleans = c(TRUE, TRUE, FALSE),\n    strings = c(\"alpha\", \"beta\", \"gamma\"),\n    row.names = c(\"first\", \"second\", \"third\"),\n    stringsAsFactors = TRUE\n)\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       numbers booleans strings\nfirst        1     TRUE   alpha\nsecond       2     TRUE    beta\nthird        3    FALSE   gamma\n```\n\n\n:::\n:::\n\n\n\nThis does not change the dataframe visually but if we will see in the following section that it has changed the datatype of the `strings` column.\n\n### Indexing Dataframes\n\nDataframe indexing behaves a lot like matrix indexing as discussed in [R Basics II (Atomic Data Structures)](/posts/rds3-basics2-atomicdata/index.qmd).",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}